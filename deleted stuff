// panel9 (General View) 

//     <div
//       class="resizable"
//       id="panel9"
//       ondrag="panelDrag(this)"
//       onclick="panelDrag(this)"
//     >
//       <p id="panel9title" class="panelTitle">Graph View</p>
//       <div id="tabs">
//         <ul>
//           <li><a href="#tabs-1">t-SNE</a></li>
//           <li><a href="#tabs-2">Force Layout</a></li>
//         </ul>
//         <div id="tabs-1" class="context-menu-four box menu-1">
//           <!-- tab1 -->
//           <span id="TsneSilhouette_label"></span>
//           <div id="general_view1">
//             <!-- Documents graph goes here (T-SNE layout) -->
//           </div>
//           <div id="tabs-1_controls">
//             <span id="slider4_label">Perplexity [5-50]:</span>
//             <input id="slider4_Textbox" type="text" onkeyup="changeSlider4()" />
//             <span id="slider4_min">5</span>
//             <span id="slider4_max">50</span>
//             <div id="slider4"></div>
//             <input
//               id="button41"
//               title="apply"
//               class="button"
//               type="button"
//               value="apply"
//               onclick="changePerplexity()"
//             />
//           </div>
//         </div>
//         <div id="tabs-2" class="context-menu-four box menu-1">
//           <!-- tab2 -->
//           <input
//             id="button19"
//             title="Silhouette"
//             class="button"
//             type="button"
//             value="Silhouette"
//             onclick="forceSilhouette()"
//           />
//           <span id="forceSilhouette_label"></span>
//           <div id="general_view2">
//             <!-- Documents graph goes here (Force layout) -->
//           </div>
//           <span id="slider3_label">Gravity (%):</span>
//           <input id="slider3_Textbox" type="text" onkeyup="changeSlider3()" />
//           <span id="slider3_min">0</span>
//           <span id="slider3_max">100</span>
//           <div id="slider3"></div>

//           <span id="slider2_label">Link Distance [0-100]:</span>
//           <input id="slider2_Textbox" type="text" onkeyup="changeSlider2()" />
//           <span id="slider2_min">0</span>
//           <span id="slider2_max">100</span>
//           <div id="slider2"></div>
//         </div>
//       </div>

//       <div id="panel9_filters">
//         <span id="filter1_label">First Filter:</span>
//         <select id="filter1_select">
//           <!-- list of filter1 are here! -->
//           <option value=""></option>
//         </select>
//         <script>
//           document.getElementById("filter1_select").onchange = function () {
//             applyFilter();
//           };
//         </script>
//         <span id="filter2_label">Second Filter:</span>
//         <select id="filter2_select">
//           <!-- list of filter2 are here! -->
//           <option value=""></option>
//         </select>
//         <script>
//           document.getElementById("filter2_select").onchange = function () {
//             applyFilter();
//           };
//         </script>
//       </div>

//       <div id="tabs-common-control">
//         <span id="slider1_label">Cosine Distance (%):</span>
//         <input id="slider1_Textbox" type="text" onkeyup="changeSlider1()" />
//         <span id="slider1_min">0</span>
//         <span id="slider1_max">97</span>
//         <div id="slider1"></div>

//         <span id="span1">#Documents: </span><span id="span2"></span>
//         <span id="span3">#Links: </span><span id="span4"></span>
//         <input
//           id="button17"
//           title="Graph VNA"
//           class="button"
//           type="button"
//           value="Graph VNA"
//           onclick="exportGraphToVNAformat($('#slider1_Textbox').val()/100)"
//         />
//         <input
//           id="button11"
//           title="MindMap"
//           class="button"
//           type="button"
//           value="MindMap"
//           onclick="MindMapClicked()"
//         />
//       </div>
//     </div>

// panel6 (Document-Cluster View)
//     <div
//       class="resizable"
//       id="panel6"
//       ondrag="panelDrag(this)"
//       onclick="panelDrag(this)"
//     >
//       <p id="panel6title" class="panelTitle">Document-Cluster View</p>
//       <div id="DocumentClusterView">
//         <!-- the svg of paralelCordinator goes here -->
//       </div>
//     </div>

/**
 * Add new term to the cluster (if a term in key term list double clicked)
 */
// $(document).ready(function () {
//   saveLog("AddTermDoubleClickList");
//   $("#selectable").dblclick(function () {
//     var term = $(this.getElementsByClassName("ui-selected")).text();

//     var terms = document
//       .getElementById(getSelectedClusterID())
//       .getElementsByClassName("sortable");

//     if (!termExists($(terms).children(), term)) {
//       //check if the term exists or not
//       appendTerm(term);
//     } else {
//       alert('This cluster already have "' + term + '"');
//     }
//   });
// });

// /**
//  * Add new term to the cluster (if a word in a documnet content double clicked)
//  */
// $(document).ready(function () {
//   saveLog("AddTermDoubleClickDocContent");
//   //if a word in a documnet content double clicked
//   $("#doc_content").dblclick(function () {
//     var term = getSelectedText();

//     var terms = document
//       .getElementById(getSelectedClusterID())
//       .getElementsByClassName("sortable");

//     if (!termExists($(terms).children(), term)) {
//       appendTerm(term);
//     } else {
//       alert('This cluster already have "' + term + '"');
//     }
//   });
// });

/**
 * append the selected term to the cluster
 * @param term = the term
 */
// function appendTerm(term) {
//   var x;
//   x = document.getElementsByClassName("cluster");
//   var i;
//   for (i = 0; i < x.length; i++) {
//     if (x[i].style.borderColor == "rgb(254, 46, 154)") {
//       $(x[i].getElementsByClassName("sortable")).append(
//         "<li class='ui-state-default ui-sortable-handle' onmousedown=\"wordMouseDown(event)\"><span class='terms'>" +
//           term +
//           "</span></li>"
//       );
//     }
//   }
// }





// * Highlight the document in general view graph
//  * @param docName = docuemnt name
//  */
// function highlightDocGeneralView(docName) {
//   node.style("stroke", function (o) {
//     if (o.na == docName) {

//       return "red";
//     }
//     // else if(docsHighlight[o.na])
//     // {
//     //   return "blue";
//     // }
//     else {
//       return "#a6a6a6";
//     }
//   });

//   node.style("stroke-width", function (o) {
//     if (o.na == docName) {
//       return "2px";
//     }
//     // else if(docsHighlight[o.na])
//     // {
//     //   return "2px";
//     // }
//     else {
//       return "0.5px";
//     }
//   });

//   node2.style("stroke", function (o) {
//     if (o.na == docName) {
//       return "red";
//     }
//     // else if(docsHighlight[o.na])
//     // {
//     //   return "blue";
//     // }
//     else {
//       return "#a6a6a6";
//     }
//   });

//   node2.style("stroke-width", function (o) {
//     if (o.na == docName) {
//       return "2px";
//     }
//     // else if(docsHighlight[o.na])
//     // {
//     //   return "2px";
//     // }
//     else {
//       return "0.5px";
//     }
//   });
// }


// function transformData_relative_Values_1(data) {
//   var transformed = [];
//   var clusters = Object.keys(data);

//   // Assuming each array in data has the same length
//   var numClusters = data[clusters[0]].length;

//   for (var i = 0; i < numClusters; i++) {
//     var clusterData = { cluster: "Cluster " + (i + 1) };
//     clusters.forEach(function (key) {
//       clusterData[key] = data[key][i];
//     });
//     transformed.push(clusterData);
//   }
//   return transformed;
// }
// function createTermClusterChart_relative_Values_1() {
// // Assuming the container div 'panel9' has been rendered and has width and height
// var panel9 = document.getElementById("panel9");
// console.log(document.getElementById("panel9"));
// console.log(panel9);
// var computedStyle = window.getComputedStyle(panel9);

// // Get the computed width and height from the CSS properties
// var panelWidth = parseFloat(computedStyle.width);
// var panelHeight = parseFloat(computedStyle.height);

// // Define margins as an object, you can adjust these values as needed
// var margin = { top: 20, right: 20, bottom: 40, left: 40 };

// // Calculate the actual width and height of the SVG canvas
// var width = panelWidth - margin.left - margin.right;
// var height = panelHeight - margin.top - margin.bottom;
// doc = document.getElementById("doc_content").innerHTML.replace(/\n$/, "");
// console.log(doc);
// documentExplanation = explanation_details[doc];
// var rawScores = documentExplanation;

// var scalingFactor = 1; // Adjust the scaling factor as needed

// // Execute the new steps
// var featureAverages = calculateFeatureAverages(rawScores);
// var relativeDifferences = computeRelativeDifferences(rawScores, featureAverages);
// var scaledDifferences = scaleUpDifferences(relativeDifferences, scalingFactor);
// var { positiveValues, negativeValues } = separatePositiveNegativeValues(scaledDifferences);

// // Transform the data for D3.js
// var transformedData = transformData_relative_Values_1(positiveValues);
// var negativeTransformedData = transformData_relative_Values_1(negativeValues);
// // var documentExplanation = {
// //   "Michael Fincke": [0.269, 0.268, 0.304, 0.290], feature: cluster 1, cluster 2, cluster 3, cluster 4
// //   "Astronaut": [0.217, 0.272, 0.278, 0.313],feature: cluster 1, cluster 2, cluster 3, cluster 4
// //   "Orbit": [0.241, 0.272, 0.280, 0.305],feature: cluster 1, cluster 2, cluster 3, cluster 4
// //   "Earth": [0.262, 0.304, 0.300, 0.304]feature: cluster 1, cluster 2, cluster 3, cluster 4
// // };

// // var data = transformData(documentExplanation);

// // Define the container and SVG dimensions
// var margin = { top: 20, right: 160, bottom: 50, left: 30 };
// var width = 960 - margin.left - margin.right,
//     height = 500 - margin.top - margin.bottom;

// // Create the SVG container
// var svg = d3.select("#chart")
//             .append("svg")
//             .attr("width", width + margin.left + margin.right)
//             .attr("height", height + margin.top + margin.bottom)
//             .append("g")
//             .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// // Set up the scales
// var xScale = d3.scale.ordinal()
//                .rangeRoundBands([0, width], .1)
//                .domain(transformedData.map(function(d) { return d.cluster; }));

// var yScale = d3.scale.linear()
//                .range([height, 0])
//                .domain([
//                  d3.min(negativeTransformedData, function(d) {
//                    return d3.sum(d3.values(d).filter(function(v) { return v < 0; }));
//                  }),
//                  d3.max(transformedData, function(d) {
//                    return d3.sum(d3.values(d).filter(function(v) { return v > 0; }));
//                  })
//                ]);
// var color = d3.scale.ordinal()
//               .range(["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"])
//               .domain(Object.keys(transformedData[0]).filter(function(key) { return key !== "cluster"; }));
              
// // Set up the axes
// var xAxis = d3.svg.axis().scale(xScale).orient("bottom");
// var yAxis = d3.svg.axis().scale(yScale).orient("left");

// // Draw the axes
// svg.append("g")
//    .attr("class", "x axis")
//    .attr("transform", "translate(0," + height + ")")
//    .call(xAxis);

// svg.append("g")
//    .attr("class", "y axis")
//    .call(yAxis)
//    .append("text")
//    .attr("transform", "rotate(-90)")
//    .attr("y", 6)
//    .attr("dy", ".71em")
//    .style("text-anchor", "end")
//    .text("Score");

// // Function to handle the stacking of bars
// function stackBars(transformedData, className, yScale) {
//   var cluster = svg.selectAll("." + className)
//                    .data(transformedData)
//                    .enter().append("g")
//                    .attr("class", "g")
//                    .attr("transform", function(d) { return "translate(" + xScale(d.cluster) + ",0)"; });

//   cluster.selectAll("rect")
//          .data(function(d) {
//            return Object.keys(d).filter(function(key) { return key !== "cluster"; }).map(function(key) {
//              return { key: key, value: d[key] };
//            });
//          })
//          .enter().append("rect")
//          .attr("width", xScale.rangeBand())
//          .attr("y", function(d) {
//           return d.value < 0 ? yScale(0) : yScale(d.value);
//         })
//         .attr("height", function(d) {
//           return Math.abs(yScale(d.value) - yScale(0));
//         })
//          .style("fill", function(d) {
//            return color(d.key);
//          });
//          cluster.selectAll(".text")
//          .data(function(d) {
//            return Object.keys(d).filter(function(key) { return key !== "cluster"; }).map(function(key) {
//              return { key: key, value: d[key] };
//            });
//          })
//          .enter().append("text")
//          .attr("class", "bar-text")
//          .attr("x", xScale.rangeBand() / 2) // Centers the text in the bar
//          .attr("y", function(d) {
//            return d.value < 0 ? yScale(0) - 5 : yScale(d.value) + 15; // Positions the text above or below the zero line based on the value
//          })
//          .text(function(d) {
//            return d.value.toFixed(2); // Formats the number to two decimal places
//          })
//          .attr("text-anchor", "middle") // Centers the text horizontally
//          .attr("fill", "black"); // Sets the text color
// }


//   // Add text labels
  
//   // Draw positive and negative bars
//   stackBars(transformedData, "positive", yScale);
//   stackBars(negativeTransformedData, "negative", yScale);

// // Calculate the legend item offsets by accumulating widths
// var legendItemOffsets = [0];
// color
//   .domain()
//   .slice()
//   .reverse()
//   .forEach(function (d, i) {
//     var textWidth = getTextWidth(d, "20px sans-serif"); // Calculate text width (you may need a helper function for this)
//     var spacing = 48; // Adjust spacing based on your styling
//     if (i > 0) {
//       legendItemOffsets.push(legendItemOffsets[i - 1] + textWidth + spacing);
//     }
//   });

// // Create legend
// var legend = svg
//   .selectAll(".legend")
//   .data(color.domain().slice().reverse())
//   .enter()
//   .append("g")
//   .attr("class", "legend")
//   .attr("transform", function (d, i) {
//     return (
//       "translate(" +
//       legendItemOffsets[i] +
//       "," +
//       (height + margin.bottom - 20) +
//       ")"
//     );
//   });

// legend
//   .append("rect")
//   .attr("x", 0)
//   .attr("width", 18)
//   .attr("height", 18)
//   .style("fill", color);

// legend
//   .append("text")
//   .attr("x", 22)
//   .attr("y", 9)
//   .attr("dy", ".35em")
//   .style("text-anchor", "start")
//   .text(function (d) {
//     return d;
//   });

// // Helper function to measure text width
// function getTextWidth(text, font) {
//   // re-use canvas object for better performance
//   var canvas =
//     getTextWidth.canvas ||
//     (getTextWidth.canvas = document.createElement("canvas"));
//   var context = canvas.getContext("2d");
//   context.font = font;
//   var metrics = context.measureText(text);
//   return metrics.width;
// }
// }

/*
 * Get general view graph
 * @param similarityThreshold = the similarity threshold
 * @return generalViewGraph = the general view graph
 */
// function getGeneralViewGraph(similarityThreshold) {
//   var scale_width = $("#general_view1").width() / 11;
//   var scale_height = $("#general_view1").height() / 11;

//   var date1 = new Date();
//   var n1 = date1.getTime();

//   var tsneSilhouetteState = false;
//   //run t-sne
//   if (tsneResult.length < 1) {
//     tsneSilhouetteState = true;
//     var opt = {};
//     opt.epsilon = 10;
//     opt.perplexity = 5;
//     opt.dim = 2;

//     // var opt = { epsilon: 10 }; // epsilon is learning rate (10 = default)
//     var tsne = new tsnejs.tSNE(opt); // create a tSNE instance
//     tsne.initDataDist(documentDocumentSimilarity);

//     for (var k = 0; k < 300; k++) {
//       tsne.step(); // every time you call this, solution gets better
//     }

//     tsneResult = tsne.getSolution(); // Y is an array of 2-D points that you can plot
//   }

//   var tsneLables = new Array();

//   var tempGeneralViewGraph = "{";

//   //add nodes
//   var documentNewIndex = [];
//   var index = 0;
//   tempGeneralViewGraph += '"nodes":[';
//   for (var i = 0; i < documentDocumentSimilarity.length; i++) {
//     if (removedDocuments[i] == false) {
//       documentNewIndex[i] = index;

//       var documentClustersName = getDocumentClustersName(documentsName[i]);
//       tempGeneralViewGraph +=
//         '{"x": ' +
//         (tsneResult[i][0] + scale_width) * 6 +
//         ', "y": ' +
//         (tsneResult[i][1] + scale_height) * 6 +
//         ', "fixed":false' +
//         ', "na":"' +
//         documentsName[i] +
//         '", "cl":"' +
//         documentClustersName +
//         '", "co":"';

//       tsneLables[index] = documentClustersName.split(",")[0];
//       index++;

//       if (documentClustersName.split(",").length > 1) {
//         tempGeneralViewGraph += 'black"},';
//       } else {
//         tempGeneralViewGraph += getClusterColor(documentClustersName) + '"},';
//       }
//     }
//   }

//   //get tsne avg silhouette
//   if (tsneSilhouetteState) {
//     getTsneSilhouette(tsneResult, tsneLables);
//   }

//   //remove the last comma
//   tempGeneralViewGraph = tempGeneralViewGraph.substring(
//     0,
//     tempGeneralViewGraph.length - 1
//   );

//   tempGeneralViewGraph += "],";

//   //add links
//   var count = 0;
//   tempGeneralViewGraph += '"links":[';
//   for (var i = 0; i < documentDocumentSimilarity.length; i++) {
//     if (removedDocuments[i] == false) {
//       for (var j = 0; j < documentDocumentSimilarity.length; j++) {
//         if (removedDocuments[j] == false) {
//           if (i != j) {
//             // no self loop (cycle)
//             if (
//               parseFloat(documentDocumentSimilarity[i][j]) <=
//               similarityThreshold
//             ) {
//               tempGeneralViewGraph +=
//                 '{"source":' +
//                 documentNewIndex[i] +
//                 ',"target":' +
//                 documentNewIndex[j] +
//                 ',"v":' +
//                 documentDocumentSimilarity[i][j] +
//                 "},";
//               count++;
//             }
//           }
//         }
//       }
//     }
//   }

//   //remove the last comma
//   tempGeneralViewGraph = tempGeneralViewGraph.substring(
//     0,
//     tempGeneralViewGraph.length - 1
//   );

//   tempGeneralViewGraph += "]}";

//   generalViewGraph2 = JSON.parse(tempGeneralViewGraph);

//   return JSON.parse(tempGeneralViewGraph);
// }

/*
 * Get  Silhouette
 * @param tsneResult =  x and y dimensions
 * @param tsneLables = labels of documents
 */
// function getTsneSilhouette(tsneResult, tsneLables) {
//   $.ajax({
//     type: "POST",
//     url: "./cgi-bin/tsneSilhouette.py",
//     data: {
//       tsneResult: JSON.stringify(tsneResult),
//       tsneLables: JSON.stringify(tsneLables),
//     },
//     success: function (msg) {
//       var status = msg["status"];
//       // console.trace("label");
//       if (status == "yes") {
//         TsneSilhouette = eval(msg["TsneSilhouette"]);
//         TsneSilhouette = TsneSilhouette.toFixed(4);

//         //show the tsne Silhouette
//         $("#TsneSilhouette_label").html("T-SNE Silhouette: " + TsneSilhouette);
//       }
//       if (status == "no") {
//         alert("Error1 in getting Tsne Silhouette!");
//       }
//       if (status == "error") {
//         alert("Error2 in getting Tsne Silhouette!");
//       }
//     },
//     error: function (msg) {
//       alert("Error3 in getting Tsne Silhouette!");
//     },
//   });
// }

/*
 * Get general view graph
 * @param similarityThreshold = the similarity threshold
 * @return graph in VNA format
 */
// function exportGraphToVNAformat(similarityThreshold) {
//   saveLog("exportGraphToVNAformat");

//   if (userID == "") {
//     return null;
//   }

//   //get VNA
//   var vna = getVNA(similarityThreshold);

//   //save VNA to file
//   $.ajax({
//     type: "POST",
//     url: "./cgi-bin/VNASave.py",
//     data: {
//       vna: JSON.stringify(vna),
//       userDirectory: JSON.stringify(userDirectory),
//     },
//     success: function (msg) {
//       var status = msg["status"];

//       if (status == "yes") {
//         //open the link of VNA in new Tab
//         window.open("./" + userID + "/vna", "_blank");
//       }
//       if (status == "no") {
//         alert("Error1 in getting graph VNA!");
//       }
//     },
//     error: function (msg) {
//       alert("Error2 in getting graph VNA!");
//     },
//   });
// }

/*
 * Get general view graph
 * @param similarityThreshold = the similarity threshold
 * @return graph in VNA format
 */
// function getVNA(similarityThreshold) {
//   saveLog("getVNA");

//   var VNA_Format = "*Node data\n";
//   VNA_Format += "id name clusters color\n";

//   //add nodes
//   var documentNewIndex = [];
//   var index = 0;
//   for (var i = 0; i < documentDocumentSimilarity.length; i++) {
//     if (removedDocuments[i] == false) {
//       documentNewIndex[i] = index;

//       var documentClustersName = getDocumentClustersName(documentsName[i]);
//       VNA_Format +=
//         index +
//         " " +
//         '"' +
//         documentsName[i] +
//         '" "' +
//         documentClustersName +
//         '" "';

//       index++;

//       if (documentClustersName.split(",").length > 1) {
//         VNA_Format += 'black"\n';
//       } else {
//         VNA_Format += getClusterColor(documentClustersName) + '"\n';
//       }
//     }
//   }

//   //add links
//   VNA_Format += "*Tie data\n";
//   VNA_Format += "from to distance\n";

//   for (var i = 0; i < documentDocumentSimilarity.length; i++) {
//     if (removedDocuments[i] == false) {
//       for (var j = 0; j < documentDocumentSimilarity.length; j++) {
//         if (removedDocuments[j] == false) {
//           if (i != j) {
//             // no self loop (cycle)
//             if (
//               parseFloat(documentDocumentSimilarity[i][j]) <=
//               similarityThreshold
//             ) {
//               VNA_Format +=
//                 documentNewIndex[i] +
//                 " " +
//                 documentNewIndex[j] +
//                 " " +
//                 documentDocumentSimilarity[i][j] +
//                 "\n";
//             }
//           }
//         }
//       }
//     }
//   }

//   return VNA_Format;
// }

// function transformData_differential_value(data) {
//   var meanScores = calculateMeanScores(data);
//   var differentialScores = calculateDifferentialScores(data, meanScores);
//   var data = normalizeScores(differentialScores);
  
//   var transformed = [];
//   var clusters = Object.keys(data);

//   // Assuming each array in data has the same length
//   var numClusters = data[clusters[0]].length;

//   for (var i = 0; i < numClusters; i++) {
//     var clusterData = { cluster: "Cluster " + (i + 1) };
//     clusters.forEach(function (key) {
//       clusterData[key] = data[key][i];
//     });
//     transformed.push(clusterData);
//   }
//   return transformed;
// }
// function createTermClusterChart_differential_values() {
//   // Assuming the container div 'panel9' has been rendered and has width and height
//   var panel9 = document.getElementById("panel9");
//   console.log(document.getElementById("panel9"));
//   console.log(panel9);
//   var computedStyle = window.getComputedStyle(panel9);

//   // Get the computed width and height from the CSS properties
//   var panelWidth = parseFloat(computedStyle.width);
//   var panelHeight = parseFloat(computedStyle.height);

//   // Define margins as an object, you can adjust these values as needed
//   var margin = { top: 20, right: 20, bottom: 40, left: 40 };

//   // Calculate the actual width and height of the SVG canvas
//   var width = panelWidth - margin.left - margin.right;
//   var height = panelHeight - margin.top - margin.bottom;
//   doc = document.getElementById("doc_content").innerHTML.replace(/\n$/, "");
//   documentExplanation = explanation_details[doc];
//   // var documentExplanation = {
//   //   "Michael Fincke": [0.269, 0.268, 0.304, 0.290], feature: cluster 1, cluster 2, cluster 3, cluster 4
//   //   "Astronaut": [0.217, 0.272, 0.278, 0.313],feature: cluster 1, cluster 2, cluster 3, cluster 4
//   //   "Orbit": [0.241, 0.272, 0.280, 0.305],feature: cluster 1, cluster 2, cluster 3, cluster 4
//   //   "Earth": [0.262, 0.304, 0.300, 0.304]feature: cluster 1, cluster 2, cluster 3, cluster 4
//   // };

//   var data = transformData_differential_value(documentExplanation);

//   var margin = { top: 20, right: 160, bottom: 50, left: 30 };

//   var width = 960 - margin.left - margin.right,
//     height = 500 - margin.top - margin.bottom;

//   var svg = d3.select("#chart").select("svg");

//   // If SVG is already present, remove it before creating a new one
//   if (!svg.empty()) {
//     svg.remove();
//   }
//   var svg = d3
//     .select("#chart")
//     .append("svg")
//     .attr("width", width + margin.left + margin.right)
//     .attr("height", height + margin.top + margin.bottom)
//     .append("g")
//     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//   var x = d3.scale
//     .ordinal()
//     .rangeRoundBands([0, width / 1.5], 0.3)
//     .domain(
//       data.map(function (d) {
//         return d.cluster;
//       })
//     );

//   var color = d3.scale
//     .ordinal()
//     // .range(["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"])
//     .range(["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5"])
//     .domain(
//       d3.keys(data[0]).filter(function (key) {
//         return key !== "cluster";
//       })
//     );
//   var y = d3.scale
//     .linear()
//     .rangeRound([height, 0])
//     .domain([
//       0,
//       d3.max(data, function (d) {
//         return d3.sum(
//           color.domain().map(function (key) {
//             return d[key];
//           })
//         );
//       }),
//     ]);

//   var xAxis = d3.svg.axis().scale(x).orient("bottom");

//   var yAxis = d3.svg.axis().scale(y).orient("left");

//   // Define the colors for each concept

//   svg
//     .append("g")
//     .attr("class", "x axis")
//     .attr("transform", "translate(0," + height + ")")
//     .call(xAxis);

//   svg
//     .append("g")
//     .attr("class", "y axis")
//     .call(yAxis)
//     .append("text")
//     .attr("transform", "rotate(-90)")
//     .attr("y", 6)
//     .attr("dy", ".71em")
//     .style("text-anchor", "end")
//     .text("Score");

//   var cluster = svg
//     .selectAll(".cluster")
//     .data(data)
//     .enter()
//     .append("g")
//     .attr("class", "g")
//     .attr("transform", function (d) {
//       return "translate(" + x(d.cluster) + ",0)";
//     });

//   cluster
//     .selectAll("rect")
//     .data(function (d) {
//       var y0 = 0;
//       return color.domain().map(function (name) {
//         return { name: name, y0: y0, y1: (y0 += +d[name]), cluster: d.cluster };
//       });
//     })
//     .enter()
//     .append("rect")
//     .attr("width", x.rangeBand())
//     .attr("y", function (d) {
//       return y(d.y1);
//     })
//     .attr("height", function (d) {
//       return y(d.y0) - y(d.y1);
//     })
//     .style("fill", function (d) {
//       return color(d.name);
//     })
//     // Add text labels
//     .each(function (d) {
//       var bar = d3.select(this);
//       var barHeight = y(d.y0) - y(d.y1);
//       if (barHeight > 20) {
//         // Only add text if the bar is tall enough
//         var barWidth = x.rangeBand();
//         var barX = x(d.cluster) + barWidth / 2; // Center of the bar
//         var barY = y(d.y1) + (y(d.y0) - y(d.y1)) / 2; // Middle of the bar height

//         svg
//           .append("text")
//           .attr("x", barX)
//           .attr("y", barY)
//           .attr("dy", "0.35em")
//           .attr("text-anchor", "middle")
//           .text(d3.format(".2f")(d.y1 - d.y0))
//           .style("fill", "black") // Choose a fill color that contrasts with the bar
//           .style("font-size", "20px"); // Adjust font size as needed
//       }
//     });

//   // Calculate the legend item offsets by accumulating widths
//   var legendItemOffsets = [0];
//   color
//     .domain()
//     .slice()
//     .reverse()
//     .forEach(function (d, i) {
//       var textWidth = getTextWidth(d, "20px sans-serif"); // Calculate text width (you may need a helper function for this)
//       var spacing = 48; // Adjust spacing based on your styling
//       if (i > 0) {
//         legendItemOffsets.push(legendItemOffsets[i - 1] + textWidth + spacing);
//       }
//     });

//   // Create legend
//   var legend = svg
//     .selectAll(".legend")
//     .data(color.domain().slice().reverse())
//     .enter()
//     .append("g")
//     .attr("class", "legend")
//     .attr("transform", function (d, i) {
//       return (
//         "translate(" +
//         legendItemOffsets[i] +
//         "," +
//         (height + margin.bottom - 20) +
//         ")"
//       );
//     });

//   legend
//     .append("rect")
//     .attr("x", 0)
//     .attr("width", 18)
//     .attr("height", 18)
//     .style("fill", color);

//   legend
//     .append("text")
//     .attr("x", 22)
//     .attr("y", 9)
//     .attr("dy", ".35em")
//     .style("text-anchor", "start")
//     .text(function (d) {
//       return d;
//     });

//   // Helper function to measure text width
//   function getTextWidth(text, font) {
//     // re-use canvas object for better performance
//     var canvas =
//       getTextWidth.canvas ||
//       (getTextWidth.canvas = document.createElement("canvas"));
//     var context = canvas.getContext("2d");
//     context.font = font;
//     var metrics = context.measureText(text);
//     return metrics.width;
//   }
// }

// function transformData(data) {
//   var transformed = [];
//   var clusters = Object.keys(data);

//   // Assuming each array in data has the same length
//   var numClusters = data[clusters[0]].length;

//   for (var i = 0; i < numClusters; i++) {
//     var clusterData = { cluster: "Cluster " + (i + 1) };
//     clusters.forEach(function (key) {
//       clusterData[key] = data[key][i];
//     });
//     transformed.push(clusterData);
//   }
//   return transformed;
// }
// function createTermClusterChartOriginal() {
//   // Assuming the container div 'panel9' has been rendered and has width and height
//   var panel9 = document.getElementById("panel9");
//   console.log(document.getElementById("panel9"));
//   console.log(panel9);
//   var computedStyle = window.getComputedStyle(panel9);

//   // Get the computed width and height from the CSS properties
//   var panelWidth = parseFloat(computedStyle.width);
//   var panelHeight = parseFloat(computedStyle.height);

//   // Define margins as an object, you can adjust these values as needed
//   var margin = { top: 20, right: 20, bottom: 40, left: 40 };

//   // Calculate the actual width and height of the SVG canvas
//   var width = panelWidth - margin.left - margin.right;
//   var height = panelHeight - margin.top - margin.bottom;
//   doc = document.getElementById("doc_content").innerHTML.replace(/\n$/, "");
//   documentExplanation = explanation_details[doc];
//   // var documentExplanation = {
//   //   "Michael Fincke": [0.269, 0.268, 0.304, 0.290], feature: cluster 1, cluster 2, cluster 3, cluster 4
//   //   "Astronaut": [0.217, 0.272, 0.278, 0.313],feature: cluster 1, cluster 2, cluster 3, cluster 4
//   //   "Orbit": [0.241, 0.272, 0.280, 0.305],feature: cluster 1, cluster 2, cluster 3, cluster 4
//   //   "Earth": [0.262, 0.304, 0.300, 0.304]feature: cluster 1, cluster 2, cluster 3, cluster 4
//   // };

//   var data = transformData(documentExplanation);

//   var margin = { top: 20, right: 160, bottom: 50, left: 30 };

//   var width = 960 - margin.left - margin.right,
//     height = 500 - margin.top - margin.bottom;

//   var svg = d3.select("#chart").select("svg");

//   // If SVG is already present, remove it before creating a new one
//   if (!svg.empty()) {
//     svg.remove();
//   }
//   var svg = d3
//     .select("#chart")
//     .append("svg")
//     .attr("width", width + margin.left + margin.right)
//     .attr("height", height + margin.top + margin.bottom)
//     .append("g")
//     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//   var x = d3.scale
//     .ordinal()
//     .rangeRoundBands([0, width / 1.5], 0.3)
//     .domain(
//       data.map(function (d) {
//         return d.cluster;
//       })
//     );

//   var color = d3.scale
//     .ordinal()
//     .range(["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5"])
//     .domain(
//       d3.keys(data[0]).filter(function (key) {
//         return key !== "cluster";
//       })
//     );
//   var y = d3.scale
//     .linear()
//     .rangeRound([height, 0])
//     .domain([
//       0,
//       d3.max(data, function (d) {
//         return d3.sum(
//           color.domain().map(function (key) {
//             return d[key];
//           })
//         );
//       }),
//     ]);

//   var xAxis = d3.svg.axis().scale(x).orient("bottom");

//   var yAxis = d3.svg.axis().scale(y).orient("left");

//   // Define the colors for each concept

//   svg
//     .append("g")
//     .attr("class", "x axis")
//     .attr("transform", "translate(0," + height + ")")
//     .call(xAxis);

//   svg
//     .append("g")
//     .attr("class", "y axis")
//     .call(yAxis)
//     .append("text")
//     .attr("transform", "rotate(-90)")
//     .attr("y", 6)
//     .attr("dy", ".71em")
//     .style("text-anchor", "end")
//     .text("Score");

//   var cluster = svg
//     .selectAll(".cluster")
//     .data(data)
//     .enter()
//     .append("g")
//     .attr("class", "g")
//     .attr("transform", function (d) {
//       return "translate(" + x(d.cluster) + ",0)";
//     });

//   cluster
//     .selectAll("rect")
//     .data(function (d) {
//       var y0 = 0;
//       return color.domain().map(function (name) {
//         return { name: name, y0: y0, y1: (y0 += +d[name]), cluster: d.cluster };
//       });
//     })
//     .enter()
//     .append("rect")
//     .attr("width", x.rangeBand())
//     .attr("y", function (d) {
//       return y(d.y1);
//     })
//     .attr("height", function (d) {
//       return y(d.y0) - y(d.y1);
//     })
//     .style("fill", function (d) {
//       return color(d.name);
//     })
//     // Add text labels
//     .each(function (d) {
//       var bar = d3.select(this);
//       var barHeight = y(d.y0) - y(d.y1);
//       if (barHeight > 20) {
//         // Only add text if the bar is tall enough
//         var barWidth = x.rangeBand();
//         var barX = x(d.cluster) + barWidth / 2; // Center of the bar
//         var barY = y(d.y1) + (y(d.y0) - y(d.y1)) / 2; // Middle of the bar height

//         svg
//           .append("text")
//           .attr("x", barX)
//           .attr("y", barY)
//           .attr("dy", "0.35em")
//           .attr("text-anchor", "middle")
//           .text(d3.format(".2f")(d.y1 - d.y0))
//           .style("fill", "black") // Choose a fill color that contrasts with the bar
//           .style("font-size", "20px"); // Adjust font size as needed
//       }
//     });

//   // Calculate the legend item offsets by accumulating widths
//   var legendItemOffsets = [0];
//   color
//     .domain()
//     .slice()
//     .reverse()
//     .forEach(function (d, i) {
//       var textWidth = getTextWidth(d, "20px sans-serif"); // Calculate text width (you may need a helper function for this)
//       var spacing = 48; // Adjust spacing based on your styling
//       if (i > 0) {
//         legendItemOffsets.push(legendItemOffsets[i - 1] + textWidth + spacing);
//       }
//     });

//   // Create legend
//   var legend = svg
//     .selectAll(".legend")
//     .data(color.domain().slice().reverse())
//     .enter()
//     .append("g")
//     .attr("class", "legend")
//     .attr("transform", function (d, i) {
//       return (
//         "translate(" +
//         legendItemOffsets[i] +
//         "," +
//         (height + margin.bottom - 20) +
//         ")"
//       );
//     });

//   legend
//     .append("rect")
//     .attr("x", 0)
//     .attr("width", 18)
//     .attr("height", 18)
//     .style("fill", color);

//   legend
//     .append("text")
//     .attr("x", 22)
//     .attr("y", 9)
//     .attr("dy", ".35em")
//     .style("text-anchor", "start")
//     .text(function (d) {
//       return d;
//     });

//   // Helper function to measure text width
//   function getTextWidth(text, font) {
//     // re-use canvas object for better performance
//     var canvas =
//       getTextWidth.canvas ||
//       (getTextWidth.canvas = document.createElement("canvas"));
//     var context = canvas.getContext("2d");
//     context.font = font;
//     var metrics = context.measureText(text);
//     return metrics.width;
//   }
// }

/*
 * load T-SNE layout
 * @param threshold = threshold for cosine distance
 */
// function loadT_SNE(threshold) {
//   $("#general_view1").html(""); //clear the screen

//   linkedByIndex = new Array();

//   var margin = { top: 5, right: 5, bottom: 5, left: 5 },
//     width = $("#general_view1").width() - margin.left - margin.right,
//     height = $("#general_view1").height() - margin.top - margin.bottom;

//   var nominal_base_node_size = 8;
//   var focus_node = null,
//     highlight_node = null;
//   var highlight_color = "black";
//   var outline = false;
//   var default_link_color = "#a6a6a6";
//   var nominal_stroke = 0.5;
//   var max_stroke = 4.5;
//   var max_base_node_size = 36;
//   var min_zoom = 0.1;
//   var max_zoom = 8;
//   var zoom = d3.behavior.zoom().scaleExtent([min_zoom, max_zoom]);
//   var towhite = "stroke";
//   if (outline) {
//     tocolor = "stroke";
//     towhite = "fill";
//   }
//   var size = d3.scale.pow().exponent(1).domain([1, 100]).range([8, 24]);

//   // svg = d3.select("#general_view").append("svg")
//   //   .attr("class", "svg")
//   //   .attr("width", width)
//   //   .attr("height", height);

//   //in order to have enough space to show the graph (min width is 300)
//   // if($("#general_view").width() < 400) {
//   //   svg = d3.select("#general_view").append("svg")
//   //   .attr("class", "svg")
//   //   .attr("width", "400px")
//   //   .attr("height", "400px");

//   //   width = 400 - margin.left - margin.right;
//   //   height = 400 - margin.top - margin.bottom;

//   // }
//   // else
//   {
//     svg = d3
//       .select("#general_view1")
//       .append("svg")
//       .attr("class", "svg")
//       .attr("width", "100%")
//       .attr("height", "100%");
//   }

//   g = svg.append("g");

//   force = d3.layout
//     .force()
//     .size([width, height])
//     .gravity(0.3)
//     .distance(20)
//     .charge(-300)
//     .alpha(0)
//     .on("tick", tick);

//   var drag = force.drag().on("dragstart", dragstart);

//   node = force.nodes();
//   link - force.links();

//   (link = g.append("g").selectAll(".link")),
//     (node = g.append("g").selectAll(".node"));

//   // d3.json("data/json5.json", function(error, json) {
//   //  if (error) throw error;

//   //filter links by threshold
//   var linkData = generalViewGraph.links.filter(function (n) {
//     if (n.v <= threshold) {
//       return n;
//     }
//   });

//   linkData.forEach(function (d) {
//     linkedByIndex[d.source + "," + d.target] = true;
//   });

//   //update #documents and # links statistics
//   $("#span2").text(generalViewGraph.nodes.length);
//   $("#span4").text(linkData.length / 2);

//   force.nodes(generalViewGraph.nodes).links(linkData);
//   // .start();

//   link = link.data(linkData).enter().append("line").attr("class", "link");

//   node = node
//     .data(generalViewGraph.nodes)
//     .enter()
//     .append("circle")
//     .attr("class", "node")
//     .style("fill", function (d) {
//       return d.co;
//     })
//     .attr("r", r)
//     .on("dblclick", dblclick)
//     .call(drag)
//     .attr("data-hasqtip", function (d) {
//       $(this).qtip({
//         content: {
//           text:
//             '<strong>Document name:</strong><br><u class="hyperLink" onclick="showDocumentPDF($(this).text())">' +
//             d.na +
//             "</u><br><br><strong>List of clusters name:</strong><br>" +
//             createListOfDocumentClustersName(d.cl, d.na) +
//             "</u><br><strong>List of top 5 terms:</strong><br>" +
//             getListOfTermsOfDocument(d.na),
//         },
//         hide: {
//           fixed: true,
//           delay: 700,
//         },
//         show: {
//           delay: 700,
//         },
//         style: {
//           classes: "qtip-rounded qtip-shadow",
//         },
//         position: {
//           my: "center right",
//           at: "center left",
//         },
//       });
//     });

//   node
//     .on("mouseover", function (d) {
//       saveLog("tSneLayoutNodeMouseOver");
//       set_highlight(d);
//     })
//     .on("click", function (d) {
//       d3.event.stopPropagation();
//       focus_node = d;
//       set_focus(d);
//       set_highlight(d);
//       saveLog("tSneLayoutNodeClick");
//     })
//     .on("mousedown", function (d) {
//       d3.event.stopPropagation();
//     })
//     .on("mouseout", function (d) {
//       exit_highlight();
//     })
//     .on("contextmenu", function (d, i) {
//       saveLog("tSneLayoutNodeContextMenue");
//       d3.event.preventDefault();
//       // react on right-clicking
//     });

//   svg
//     .on("click", function () {
//       if (focus_node != null) {
//         focus_node = null;
//         if (highlight_trans < 1) {
//           node.style("opacity", 1);
//           link.style("opacity", 1);

//           node2.style("opacity", 1);
//           link2.style("opacity", 1);
//         }
//       } else {
//         node.style("opacity", 1);
//         link.style("opacity", 1);

//         node2.style("opacity", 1);
//         link2.style("opacity", 1);
//       }
//       if (highlight_node == null) exit_highlight();
//     })
//     .on("contextmenu", function (d, i) {
//       d3.event.preventDefault();
//       // react on right-clicking
//     });

//   // node.on("dblclick.zoom", function(d) { d3.event.stopPropagation();
//   //   var dcx = (window.innerWidth/2-d.x*zoom.scale());
//   //   var dcy = (window.innerHeight/2-d.y*zoom.scale());
//   //   zoom.translate([dcx,dcy]);
//   //   g.attr("transform", "translate("+ dcx + "," + dcy  + ")scale(" + zoom.scale() + ")");
//   // });

//   // });

//   node.classed("fixed", function (d) {
//     d.fixed = false;
//   });

//   force.start();
//   for (var i = 0; i < 2; i++) force.tick();

//   node.classed("fixed", function (d) {
//     d.fixed = true;
//   });

//   function tick() {
//     // node.attr("cx", function(d) { return d.x = Math.max(r, Math.min(width - r, d.x)); })
//     //     .attr("cy", function(d) { return d.y = Math.max(r, Math.min(height - r, d.y)); });

//     node
//       .attr("cx", function (d) {
//         return (d.x = d.x);
//       })
//       .attr("cy", function (d) {
//         return (d.y = d.y);
//       });

//     link
//       .attr("x1", function (d) {
//         return d.source.x;
//       })
//       .attr("y1", function (d) {
//         return d.source.y;
//       })
//       .attr("x2", function (d) {
//         return d.target.x;
//       })
//       .attr("y2", function (d) {
//         return d.target.y;
//       });
//   }

//   function dblclick(d) {
//     // d3.select(this).classed("fixed", d.fixed = false);
//   }

//   function dragstart(d) {
//     // d3.select(this).classed("fixed", d.fixed = true);
//   }

//   function isNumber(n) {
//     return !isNaN(parseFloat(n)) && isFinite(n);
//   }

//   function set_highlight(d) {
//     svg.style("cursor", "pointer");
//     svg2.style("cursor", "pointer");
//     if (focus_node != null) d = focus_node;
//     highlight_node = d;

//     if (highlight_color != "#a6a6a6") {
//       node.style(towhite, function (o) {
//         if (o.na == $(doc_select).val()) {
//           return "red";
//         }
//         // else if(docsHighlight[o.na])
//         // {
//         //   return "blue";
//         // }
//         else if (isConnected(d, o)) {
//           return highlight_color;
//         } else {
//           return "#a6a6a6";
//         }
//       });

//       link.style("stroke", function (o) {
//         return o.source.index == d.index || o.target.index == d.index
//           ? highlight_color
//           : isNumber(o.score) && o.score >= 0
//           ? color(o.score)
//           : default_link_color;
//       });

//       //set node stroke
//       node.style("stroke-width", function (o) {
//         if (
//           (docsHighlight[o.na] && isConnected(d, o)) ||
//           o.na == $(doc_select).val()
//         ) {
//           return "2px";
//         } else {
//           return "0.5px";
//         }
//       });

//       node2.style(towhite, function (o) {
//         if (o.na == $(doc_select).val()) {
//           return "red";
//         }
//         // else if(docsHighlight[o.na])
//         // {
//         //   return "blue";
//         // }
//         else if (isConnected(d, o)) {
//           return highlight_color;
//         } else {
//           return "#a6a6a6";
//         }
//       });

//       link2.style("stroke", function (o) {
//         return o.source.index == d.index || o.target.index == d.index
//           ? highlight_color
//           : isNumber(o.score) && o.score >= 0
//           ? color(o.score)
//           : default_link_color;
//       });

//       //set node stroke
//       node2.style("stroke-width", function (o) {
//         if (
//           (docsHighlight[o.na] && isConnected(d, o)) ||
//           o.na == $(doc_select).val()
//         ) {
//           return "2px";
//         } else {
//           return "0.5px";
//         }
//       });
//     }
//   }

//   function exit_highlight() {
//     highlight_node = null;
//     if (focus_node == null) {
//       svg.style("cursor", "move");
//       if (highlight_color != "#a6a6a6") {
//         node.style(towhite, function (o) {
//           if (o.na == $(doc_select).val()) {
//             return "red";
//           }
//           // else if(docsHighlight[o.na])
//           // {
//           //   return "blue";
//           // }
//           else {
//             return "#a6a6a6";
//           }
//         });
//         link.style("stroke", function (o) {
//           return isNumber(o.score) && o.score >= 0
//             ? color(o.score)
//             : default_link_color;
//         });

//         //set node stroke
//         node.style("stroke-width", function (o) {
//           if (o.na == $(doc_select).val()) {
//             return "2px";
//           } else {
//             return "0.5px";
//           }
//         });
//       }
//     }
//   }

//   zoom.on("zoom", function () {
//     var stroke = nominal_stroke;

//     if (nominal_stroke * zoom.scale() > max_stroke) {
//       stroke = max_stroke / zoom.scale();
//     }

//     link.style("stroke-width", stroke);
//     // node.style("stroke-width",stroke);

//     node.style("stroke-width", function (o) {
//       if (o.na == $(doc_select).val()) {
//         return stroke * 3;
//       } else {
//         return stroke;
//       }
//     });

//     var base_radius = nominal_base_node_size;

//     g.attr(
//       "transform",
//       "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")"
//     );
//   });

//   svg.call(zoom);
// } //*******************************End of T-SNE

// Calculate mean score for each feature across all clusters
// function calculateMeanScores(data) {
//   var meanScores = {};
//   for (var feature in data) {
//       var scores = data[feature];
//       var sum = scores.reduce(function(a, b) { return a + b; }, 0);
//       meanScores[feature] = sum / scores.length;
//   }
//   return meanScores;
// }
// // Calculate differential scores for each feature
// function calculateDifferentialScores(data, meanScores) {
//   var differentialScores = {};
//   for (var feature in data) {
//       differentialScores[feature] = data[feature].map(function(score) {
//           return score - meanScores[feature];
//       });
//   }
//   return differentialScores;
// }
// // Normalize the differential scores
// function normalizeScores(differentialScores) {
//   var allDifferentials = [].concat.apply([], Object.values(differentialScores));
//   var minDiff = Math.min.apply(Math, allDifferentials);
//   var maxDiff = Math.max.apply(Math, allDifferentials.map(function(d) { return d - minDiff; }));

//   var normalizedScores = {};
//   for (var feature in differentialScores) {
//       normalizedScores[feature] = differentialScores[feature].map(function(d) {
//           return (d - minDiff) / maxDiff;
//       });
//   }
//   return normalizedScores;
// }

// // Step 1: Calculate Feature Averages Across Clusters
// function calculateFeatureAverages(rawScores) {
//   let featureAverages = {};
//   for (let feature in rawScores) {
//     let total = rawScores[feature].reduce((acc, score) => acc + score, 0);
//     featureAverages[feature] = total / rawScores[feature].length;
//   }
//   return featureAverages;
// }
// // Step 2: Compute Relative Differences
// function computeRelativeDifferences(rawScores, featureAverages) {
//   let relativeDifferences = {};
//   for (let feature in rawScores) {
//     relativeDifferences[feature] = rawScores[feature].map(score => score - featureAverages[feature]);
//   }
//   return relativeDifferences;
// }
// // Step 3: Scale Up the Relative Differences
// function scaleUpDifferences(relativeDifferences, scalingFactor) {
//   let scaledDifferences = {};
//   for (let feature in relativeDifferences) {
//     scaledDifferences[feature] = relativeDifferences[feature].map(difference => difference * scalingFactor);
//   }
//   return scaledDifferences;
// }
// Step 4: Separate Positive and Negative Contributions
// function separatePositiveNegativeValues(scaledDifferences) {
//   let positiveValues = {};
//   let negativeValues = {};
//   for (let feature in scaledDifferences) {
//     positiveValues[feature] = scaledDifferences[feature].map(value => Math.max(0, value));
//     negativeValues[feature] = scaledDifferences[feature].map(value => Math.min(0, value));
//   }
//   return { positiveValues, negativeValues };
// }


// success: function (msg) {
//   let concept_support = msg["concept_support"];
//   let docElement = document.getElementById("doc_content");

//   // Sort entities by start index to avoid conflicts during replacements
//   let entities = Object.keys(concept_support).sort((a, b) => {
//       return concept_support[a]["largestRangeFrom"] - concept_support[b]["largestRangeFrom"];
//   });

//   // Convert HTML string into a DOM Node
//   let parser = new DOMParser();
//   let docContent = parser.parseFromString(docElement.innerHTML, "text/html").body;

//   // Offset to keep track of modifications
//   let offset = 0;

//   entities.forEach(entity => {
//       let currentColor = color(entity);
//       let start = concept_support[entity]["largestRangeFrom"] + offset;
//       let end = concept_support[entity]["largestRangeTo"] + offset;
//       let range = document.createRange();
      
//       try {
//           // Set the start and end positions of the range
//           range.setStart(docContent.firstChild, start);
//           range.setEnd(docContent.firstChild, end);
          
//           // Create a new span element for highlighting
//           let newNode = document.createElement("span");
//           newNode.style.backgroundColor = currentColor;
//           newNode.style.color = "white";
//           newNode.style.fontWeight = "bold";
//           newNode.appendChild(range.extractContents());  // Move the selected text into the span
          
//           // Insert the new span element into the content
//           range.insertNode(newNode);

//           // Adjust the offset by adding the length of the new HTML markup
//           offset += newNode.outerHTML.length - (end - start);
//       } catch(e) {
//           console.error("Error setting range for highlighting:", e);
//       }
//   });

//   // Update the innerHTML of the original document element
//   docElement.innerHTML = docContent.firstChild.innerHTML;
// },


/*
 * Change Cosine distance of general view graph
 * @param value = value
 */
// function graphCosineDistanceChange(value) {
//   $("#forceSilhouette_label").html("");

//   saveLog("graphCosineDistanceChange");

//   if (userID != "") {
//     value = value / 100;

//     //exit highligted node
//     node.style("stroke", function (o) {
//       if (o.na == $(doc_select).val()) {
//         return "red";
//       }
//       // else if(docsHighlight[o.na])
//       // {
//       //   return "blue";
//       // }
//       else {
//         return "#a6a6a6";
//       }
//     });
//     node.style("opacity", 1);
//     link.style("opacity", 1);
//     link.style("stroke", "#a6a6a6");

//     node2.style("stroke", function (o) {
//       if (o.na == $(doc_select).val()) {
//         return "red";
//       }
//       // else if(docsHighlight[o.na])
//       // {
//       //   return "blue";
//       // }
//       else {
//         return "#a6a6a6";
//       }
//     });
//     node2.style("opacity", 1);
//     link2.style("opacity", 1);
//     link2.style("stroke", "#a6a6a6");

//     var newLinks = generalViewGraph.links.filter(function (n) {
//       if (n.v <= value) {
//         return n;
//       }
//     });

//     var newLinks2 = generalViewGraph2.links.filter(function (n) {
//       if (n.v <= value) {
//         return n;
//       }
//     });

//     //for links
//     force.links(newLinks).resume();
//     link = link.data(newLinks);
//     link.exit().remove();
//     link.enter().append("line").attr("class", "link");
//     force.start();

//     force2.links(newLinks2).resume();
//     link2 = link2.data(newLinks2);
//     link2.exit().remove();
//     link2.enter().append("line").attr("class", "link");
//     force2.start();

//     linkedByIndex = new Array();
//     newLinks.forEach(function (d) {
//       linkedByIndex[d.source.index + "," + d.target.index] = true;
//     });

//     linkedByIndex2 = new Array();
//     newLinks2.forEach(function (d) {
//       linkedByIndex2[d.source.index + "," + d.target.index] = true;
//     });

//     //update # links statistics
//     $("#span4").text(newLinks.length / 2);
//   }
// }
/*
 * Change link distance of general view graph
 * @param value = value
 */
// function graphLinkDistanceChange(value) {
//   saveLog("graphLinkDistanceChange");
//   $("#forceSilhouette_label").html("");

//   if (userID != "") {
//     linkDistance = value;
//     force2.linkDistance(linkDistance);
//     force2.start();
//   }
// }
/*
 * Change Gravity of general view graph
 * @param value = value
 */
// function graphGravityChange(value) {
//   saveLog("graphGravityChange");
//   $("#forceSilhouette_label").html("");

//   if (userID != "") {
//     gravity = value / 100;
//     force2.gravity(gravity);

//     force2.start();
//   }
// }
/*
/**
 * Show the term cload of the document
 * @param documentName = docuemnt name
 */
// function showDocumentCloud(documentName) {
//   saveLog("showDocumentCloud");

//   if ($("#doc_content").text().length <= 1) {
//     return null;
//   }

//   //get sorted list of top terms of the document
//   var terms = getDocumentTermsSorted(documentName);

//   //get top 30 terms
//   var wordsTemp = "";
//   for (var i = 0; i < terms.length; i++) {
//     if (i == 0) {
//       wordsTemp += terms[i][0] + "|" + Math.floor(terms[i][1] * 15);
//     } else {
//       wordsTemp += "|" + terms[i][0] + "|" + Math.floor(terms[i][1] * 15);
//     }

//     if (i >= 29) {
//       break;
//     }
//   }

//   //clear the cloud
//   $("#panel8_2").html("");

//   if (wordsTemp != "") {
//     var words = wordsTemp.split("|");
//     var x = document.getElementById("cloudColor");
//     var title = "Term Cloud (Selected Document)";
//     wordCloud(
//       wordText(words),
//       sizeOfText(words),
//       "panel8_2",
//       "panel8",
//       title
//     );
//   }
// }
/*
 * load general view
 * @parm threshold = threshold for cosine distance
 */
// function generalViewLoader(threshold) {
//   //load T-SNE layout
//   // loadT_SNE(threshold);
//   //load Force layout
//   // load_Force(threshold);
// }

/*
 * load force layout
 * @parm threshold = threshold for cosine distance
 */
// function load_Force(threshold) {
//   $("#general_view2").html(""); //clear the screen
//   linkedByIndex2 = new Array();

//   var margin = { top: 5, right: 5, bottom: 5, left: 5 },
//     width = $("#general_view1").width() - margin.left - margin.right,
//     height = $("#general_view1").height() - margin.top - margin.bottom;

//   var nominal_base_node_size = 8;
//   var focus_node = null,
//     highlight_node = null;
//   var highlight_color = "black";
//   var outline = false;
//   var default_link_color = "#a6a6a6";
//   var nominal_stroke = 0.5;
//   var max_stroke = 4.5;
//   var max_base_node_size = 36;
//   var min_zoom = 0.1;
//   var max_zoom = 8;
//   var zoom = d3.behavior.zoom().scaleExtent([min_zoom, max_zoom]);
//   var towhite = "stroke";
//   if (outline) {
//     tocolor = "stroke";
//     towhite = "fill";
//   }
//   var size = d3.scale.pow().exponent(1).domain([1, 100]).range([8, 24]);

//   svg2 = d3
//     .select("#general_view2")
//     .append("svg")
//     .attr("class", "svg")
//     .attr("width", "100%")
//     .attr("height", "100%");

//   g2 = svg2.append("g");

//   force2 = d3.layout
//     .force()
//     .size([width, height])
//     .gravity(gravity)
//     .distance(linkDistance)
//     .charge(-50)
//     .on("tick", tick);

//   var drag = force2.drag().on("dragstart", dragstart);

//   node2 = force2.nodes();
//   link2 = force2.links();

//   (link2 = g2.append("g").selectAll(".link2")),
//     (node2 = g2.append("g").selectAll(".node2"));

//   // d3.json("data/json5.json", function(error, json) {
//   //  if (error) throw error;

//   //filter links by threshold
//   var linkData = generalViewGraph2.links.filter(function (n) {
//     if (n.v <= threshold) {
//       return n;
//     }
//   });

//   linkData.forEach(function (d) {
//     linkedByIndex2[d.source + "," + d.target] = true;
//   });

//   //update #documents and # links statistics
//   $("#span2").text(generalViewGraph2.nodes.length);
//   $("#span4").text(linkData.length / 2);

//   force2.nodes(generalViewGraph2.nodes).links(linkData).start();

//   link2 = link2.data(linkData).enter().append("line").attr("class", "link2");

//   node2 = node2
//     .data(generalViewGraph2.nodes)
//     .enter()
//     .append("circle")
//     .attr("class", "node2")
//     .style("fill", function (d) {
//       return d.co;
//     })
//     .attr("r", r)
//     .on("dblclick", dblclick)
//     .call(drag)
//     .attr("data-hasqtip", function (d) {
//       $(this).qtip({
//         content: {
//           text:
//             '<strong>Document name:</strong><br><u class="hyperLink" onclick="showDocumentPDF($(this).text())">' +
//             d.na +
//             "</u><br><br><strong>List of clusters name:</strong><br>" +
//             createListOfDocumentClustersName(d.cl, d.na) +
//             "</u><br><strong>List of top 5 terms:</strong><br>" +
//             getListOfTermsOfDocument(d.na),
//         },
//         hide: {
//           fixed: true,
//           delay: 700,
//         },
//         show: {
//           delay: 1500,
//         },
//         style: {
//           classes: "qtip-rounded qtip-shadow",
//         },
//         position: {
//           my: "center right",
//           at: "center left",
//         },
//       });
//     });

//   node2
//     // .on("mouseover", function (d) {
//     //   saveLog("forceLayoutNodeMouseOver");
//     //   force2.stop();
//     //   set_highlight(d);
//     // })
//     .on("click", function (d) {
//       force2.stop();
//       d3.event.stopPropagation();
//       focus_node = d;
//       set_focus(d);
//       set_highlight(d);
//       saveLog("forceLayoutNodeClick");
//     })
//     .on("mousedown", function (d) {
//       force2.stop();
//       d3.event.stopPropagation();
//     })
//     .on("mouseout", function (d) {
//       force2.stop();
//       exit_highlight();
//     })
//     .on("contextmenu", function (d, i) {
//       saveLog("forceLayoutNodeShowCloud");
//       force2.stop();
//       d3.event.preventDefault();
//       // react on right-clicking
//     });

//   svg2
//     .on("click", function () {
//       force2.stop();
//       if (focus_node != null) {
//         focus_node = null;
//         if (highlight_trans < 1) {
//           node2.style("opacity", 1);
//           link2.style("opacity", 1);

//           node.style("opacity", 1);
//           link.style("opacity", 1);
//         }
//       } else {
//         node2.style("opacity", 1);
//         link2.style("opacity", 1);

//         node.style("opacity", 1);
//         link.style("opacity", 1);
//       }
//       if (highlight_node == null) exit_highlight();
//     })
//     .on("contextmenu", function (d, i) {
//       d3.event.preventDefault();
//       // react on right-clicking
//     });

//   // node.on("dblclick.zoom", function(d) { d3.event.stopPropagation();
//   //   var dcx = (window.innerWidth/2-d.x*zoom.scale());
//   //   var dcy = (window.innerHeight/2-d.y*zoom.scale());
//   //   zoom.translate([dcx,dcy]);
//   //   g.attr("transform", "translate("+ dcx + "," + dcy  + ")scale(" + zoom.scale() + ")");
//   // });

//   // });

//   function tick() {
//     link2
//       .attr("x1", function (d) {
//         return d.source.x;
//       })
//       .attr("y1", function (d) {
//         return d.source.y;
//       })
//       .attr("x2", function (d) {
//         return d.target.x;
//       })
//       .attr("y2", function (d) {
//         return d.target.y;
//       });

//     node2
//       .attr("cx", function (d) {
//         return d.x;
//       })
//       .attr("cy", function (d) {
//         return d.y;
//       });
//   }

//   function dblclick(d) {
//     d3.select(this).classed("fixed", (d.fixed = false));
//   }

//   function dragstart(d) {
//     d3.select(this).classed("fixed", (d.fixed = true));
//   }

//   function isConnected(a, b) {
//     return (
//       linkedByIndex2[a.index + "," + b.index] ||
//       linkedByIndex2[b.index + "," + a.index] ||
//       a.index == b.index
//     );
//   }

//   function isNumber(n) {
//     return !isNaN(parseFloat(n)) && isFinite(n);
//   }

//   function set_highlight(d) {
//     svg2.style("cursor", "pointer");
//     svg.style("cursor", "pointer");
//     if (focus_node != null) d = focus_node;
//     highlight_node = d;

//     if (highlight_color != "#a6a6a6") {
//       node2.style(towhite, function (o) {
//         if (o.na == $(doc_select).val()) {
//           return "red";
//         }
//         // else if(docsHighlight[o.na])
//         // {
//         //   return "blue";
//         // }
//         else if (isConnected(d, o)) {
//           return highlight_color;
//         } else {
//           return "#a6a6a6";
//         }
//       });

//       link2.style("stroke", function (o) {
//         return o.source.index == d.index || o.target.index == d.index
//           ? highlight_color
//           : isNumber(o.score) && o.score >= 0
//           ? color(o.score)
//           : default_link_color;
//       });

//       //set node stroke
//       node2.style("stroke-width", function (o) {
//         if (
//           (docsHighlight[o.na] && isConnected(d, o)) ||
//           o.na == $(doc_select).val()
//         ) {
//           return "2px";
//         } else {
//           return "0.5px";
//         }
//       });

//       node.style(towhite, function (o) {
//         if (o.na == $(doc_select).val()) {
//           return "red";
//         }
//         // else if(docsHighlight[o.na])
//         // {
//         //   return "blue";
//         // }
//         else if (isConnected(d, o)) {
//           return highlight_color;
//         } else {
//           return "#a6a6a6";
//         }
//       });

//       link.style("stroke", function (o) {
//         return o.source.index == d.index || o.target.index == d.index
//           ? highlight_color
//           : isNumber(o.score) && o.score >= 0
//           ? color(o.score)
//           : default_link_color;
//       });

//       //set node stroke
//       node.style("stroke-width", function (o) {
//         if (
//           (docsHighlight[o.na] && isConnected(d, o)) ||
//           o.na == $(doc_select).val()
//         ) {
//           return "2px";
//         } else {
//           return "0.5px";
//         }
//       });
//     }
//   }

//   function exit_highlight() {
//     highlight_node = null;
//     if (focus_node == null) {
//       svg2.style("cursor", "move");
//       if (highlight_color != "#a6a6a6") {
//         node2.style(towhite, function (o) {
//           if (o.na == $(doc_select).val()) {
//             return "red";
//           }
//           // else if(docsHighlight[o.na])
//           // {
//           //   return "blue";
//           // }
//           else {
//             return "#a6a6a6";
//           }
//         });
//         link2.style("stroke", function (o) {
//           return isNumber(o.score) && o.score >= 0
//             ? color(o.score)
//             : default_link_color;
//         });

//         //set node stroke
//         node2.style("stroke-width", function (o) {
//           if (o.na == $(doc_select).val()) {
//             return "2px";
//           } else {
//             return "0.5px";
//           }
//         });
//       }
//     }
//   }

//   zoom.on("zoom", function () {
//     var stroke = nominal_stroke;

//     if (nominal_stroke * zoom.scale() > max_stroke) {
//       stroke = max_stroke / zoom.scale();
//     }

//     link2.style("stroke-width", stroke);
//     // node.style("stroke-width",stroke);

//     node2.style("stroke-width", function (o) {
//       if (o.na == $(doc_select).val()) {
//         return stroke * 3;
//       } else {
//         return stroke;
//       }
//     });

//     var base_radius = nominal_base_node_size;

//     g2.attr(
//       "transform",
//       "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")"
//     );
//   });

//   svg2.call(zoom);
// } //************************* End of force layout load

// {/* <script>
        // document.getElementById("doc_select").onchange = function () { */}
        //   document.getElementById("doc_content").innerHTML = "vuyvuyvkuvuv";
        //   loadDoc(this.value);
        // createTermClusterChart(this.value);

        //   //show the paralel cordinator view
        //   var words = new Array(1);
        //   var colors = {};
        //   words[0] = this.value;
        //   colors[words[0]] = $("#" + getSelectedClusterID() + " p").css(
        //     "background-color"
        //   ); //"Blue";
        //   paralelCordinator(
        //     documentClusterData,
        //     "#panel6",
        //     words,
        //     "#DocumentClusterView",
        //     colors
        //   );

        //   //highlight the document in general view
        //   // highlightDocGeneralView(this.value);
        //   createTermClusterChart();

        //   //change the color of selected doc to red
        //   $(this).css("color", "red");
        //   var options = this.children;
        //   for (var i = 0; i < this.childElementCount; i++) {
        //     if (options[i].value == this.value) options[i].style.color = "red";
        //     else options[i].style.color = "black";
        //   }
        // };
    //   </script>

//     <select id="doc_select">
//     <!-- list of documnets are here! -->
//   </select>
// <!-- <input
// id="button15"
// title="ShowPDF"
// class="button"
// type="button"
// value="ShowPDF"
// onclick="showDocumentPDF(document.getElementById('doc_select').value)"
// />
// <input
// id="button16"
// title="ShowCloud"
// class="button"
// type="button"
// value="ShowCloud"
// onclick="showDocumentCloud(document.getElementById('doc_select').value)"
// /> -->

// <!-- <input
// id="button2"
// title="Upload Document"
// class="button"
// type="button"
// value="Upload Document"
// onclick="openUploadPage()"
// /> -->
// <!-- <input
// id="button3"
// title="Save Session"
// class="button"
// type="button"
// value="Save Session"
// onclick="saveSession()"
// />
// <input
// id="button14"
// title="Delete Session"
// class="button"
// type="button"
// value="Delete Session"
// onclick="deleteSession()"
// /> -->
// <!-- <input
// id="button18"
// title="Add Note"
// class="button"
// type="button"
// value="Note"
// /> -->
// <!-- <select id="session_select"> -->
// <!-- list of sessions are here! -->
// <!-- <option value="first" disabled selected>Select Session</option>
// </select>
// <input type="checkbox" id="auto_save_session" /><span
// id="auto_save_session_text"
// >Auto save session</span -->
// <!-- ><br /> -->
// <!-- <input
// id="button4"
// title="Cluster"
// class="button"
// type="button"
// value="Cluster"
// onclick="SendData2Server()"
// />

// <span id="slider0_label">Confidence (%):</span>
// <input id="slider0_Textbox" type="text" onkeyup="changeSlider0()" />
// <span id="slider0_min">0</span>
// <span id="slider0_max">100</span>
// <div id="slider0"></div>

// <span id="Clustering_algo_text_main">Clustering <br />Method:</span>
// <select id="Clustering_algo_select_main">
// <option value="LDC">LDC</option>
// <option value="iK-means">iK-means</option>
// </select>
// <script>
// document.getElementById("Clustering_algo_select_main").onchange =
//   function () {
//     clusteringMethod = $("#Clustering_algo_select_main").val();
//     if (clusteringMethod == "LDC") {
//       $("#slider0").slider("disable");
//       $("#slider0_Textbox").attr("disabled", "disabled");
//     } else if (clusteringMethod == "iK-means") {
//       $("#slider0").slider("enable");
//       $("#slider0_Textbox").removeAttr("disabled");
//     }
//   };
// </script> -->

// <!-- <input
// id="textbox1"
// title=""
// placeholder="Search"
// onclick="selectText()"
// class="textbox"
// autocomplete="on"
// type="text"
// width="800px"
// />
// <script>
// document.getElementById("session_select").onchange = function () {
//   $("body").css("cursor", "wait");

//   var ok = confirm(
//     "Do you want to load this session? Please save your work before."
//   );

//   if (!ok) {
//     $("#session_select option[value='first']").attr("selected", true);
//     $("body").css("cursor", "auto");
//     return null;
//   }

//   var sessionName = this.value;

//   loadSession(sessionName);
// };
// </script> -->

// function openFeedbackPopup() {
//   var popup = window.open('', 'Feedback Form', 'width=600,height=400');

//   popup.document.write('<html><head><title>Feedback Form</title></head><body>');
//   popup.document.write('<h1>Provide Your Feedback</h1>');
//   popup.document.write('<p>1) Does the explanation logically support the article\'s categorization?</p>');
//   popup.document.write('<input type="radio" id="yes" name="support" value="Yes"><label for="yes">Yes</label><br>');
//   popup.document.write('<input type="radio" id="no" name="support" value="No" ><label for="no">No</label><br>');

//   popup.document.write('<div id="additionalQuestions" style="display:block;">'); // Wrap additional questions
//   //add a text area for the user to provide feedback if they answered no to the first question
//   popup.document.write('<textarea id="feedbackText" rows="4" cols="50" placeholder="Please provide feedback here"></textarea>');
//   popup.document.write('<p>2) Are you satisfied with the depth and detail of the explanation?</p>');
//   popup.document.write('<form>');
//   // Add radio buttons for scale 1 to 5
//   for (var i = 1; i <= 5; i++) {
//       popup.document.write('<input type="radio" id="scale' + i + '" name="depth" value="' + i + '">');
//       popup.document.write('<label for="scale' + i + '">' + i + '</label><br>');
//   }
//   popup.document.write('</form>');
//   popup.document.write('<button onclick="window.opener.submitFeedback()">Submit Feedback</button>'); // Moved the button inside the div
//   popup.document.write('</div>'); // Close the additionalQuestions div

//   popup.document.write('<script>');
//   popup.document.write('document.getElementById("no").addEventListener("change", function() { document.getElementById("additionalQuestions").style.display = "block"; });');
//   popup.document.write('document.getElementById("yes");');
// popup.document.write('function submitAndClose() {');
// popup.document.write('  window.opener.submitFeedback();'); // Call the function in the parent window to handle the feedback submission
// popup.document.write('  window.close();'); // Close the popup window
// popup.document.write('}');
// popup.document.write('document.getElementById("no").addEventListener("change", function() { document.getElementById("additionalQuestions").style.display = "block"; });');
// popup.document.write('document.getElementById("yes").addEventListener("change", function() { document.getElementById("additionalQuestions").style.display = "none"; });');
// popup.document.write('</script>');

//   popup.document.write('</body></html>');
//   popup.document.close(); dcds
// }

// function submitFeedback(feedbackText) {
//   // Use AJAX to send feedback to the server
//   console.log("Feedback text: " + feedbackText);
//   // Implement AJAX request to send feedbackText to your server
// }

/**
 * Download the selected cluster
 * @param clusterName = cluster name
 */
// function downloadCluster(clusterName) {
//   saveLog("downloadCluster");

//   //change the mouse icon
//   $("body").css("cursor", "wait");

//   //get the original cluster name
//   var originalName = "Cluster" + (parseInt($("#" + clusterName).index()) + 1);

//   //check if the zip file exists
//   if (checkFileExists(originalName)) {
//     $("body").css("cursor", "auto");
//     window.open("./" + userID + "/" + originalName + ".zip");
//   } else if (checkFileExists("Cluster1")) {
//     $("body").css("cursor", "auto");
//     alert(
//       "This is a new cluster, you need to push 'Cluster' button first then you can download this cluster."
//     );
//   } else {
//     //create the zip file of cluster
//     alert("Please be patient while the ZIP file is creating!");
//     $.ajax({
//       url: "./cgi-bin/documentClusters.py",
//       type: "POST",
//       async: false,
//       cache: false,
//       traditional: true,
//       data: { userDirectory: userDirectory },
//       success: function (msg) {
//         $("body").css("cursor", "auto");
//       },
//       error: function (msg) {
//         $("body").css("cursor", "auto");
//         alert("Internal Server Error: unsuccessful load data from server");
//         $("body").css("cursor", "auto");
//       },
//     });

//     if (checkFileExists(originalName)) {
//       $("body").css("cursor", "auto");
//       window.open("./" + userID + "/" + originalName + ".zip");
//     } else {
//       $("body").css("cursor", "auto");
//       alert(
//         "This is a new cluster, you need to push 'Cluster' button first then you can download this cluster."
//       );
//     }
//   }
// }

// documentClusterDataString.py

// #!/home/ubuntu/IDC/bin/python

// # Author: Ehsan Sherkat - 2017
// import sys
// import json
// import cgi, cgitb
// import zipfile
// import os
// from dotenv import load_dotenv
// import os

// # Load environment variables from .env file
// load_dotenv()
// cgitb.enable()

// form = cgi.FieldStorage()

// userDirectory = eval(form.getvalue('userDirectory'))
// serverClusterName = eval(form.getvalue('serverClusterName'))

// try:
//     documentClusters = userDirectory +os.getenv('MODE')+ 'documentClusters'
//     documentClustersCSV = open(documentClusters, 'r')

//     zipCollection = zipfile.ZipFile(userDirectory + 'collection.zip', mode='w') #zip all clusters

//     for index, clusterDocs in enumerate(documentClustersCSV):
//         if ',' in clusterDocs:
//             clusterDocs = clusterDocs.replace('\n', '').replace('\r', '')
//             clusterDocs = clusterDocs.split(',')

//             zipcluster = zipfile.ZipFile(userDirectory + serverClusterName[index] + '.zip', mode='w') #zip a cluster        

//             for doc in clusterDocs:
//                 zipcluster.write(userDirectory + doc, doc)
//                 zipCollection.write(userDirectory + doc, serverClusterName[index] + "/" + doc )

//             zipcluster.close()
//     zipCollection.close()

//     print("Content-type:application/json\r\n\r\n")
//     print(json.dumps({'status':'yes', 'message':json.dumps(str(serverClusterName))}))

// except Exception as e:
//     exc_type, exc_obj, exc_tb = sys.exc_info()
//     fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
//     print("Content-type:application/json\r\n\r\n")
//     print(json.dumps({'status':'error', 'except':json.dumps(str(e) + " Error line:" + str(exc_tb.tb_lineno) + " Error type:" + str(exc_type) + " File name:" + fname)}))

/*
 * Delete the selected session.
 */
// function deleteSession() {
//   saveLog("deleteSession");

//   if (userID != "") {
//     var sessionName = $("#session_select").val();

//     if (sessionName != null) {
//       var confirmed = confirm("Are you sure about deleting this session?");

//       if (confirmed) {
//         var date = sessionName
//           .substring(sessionName.indexOf(" @ ") + 3)
//           .replace("_", ":")
//           .replace("_", ":");
//         var name = sessionName.substring(0, sessionName.indexOf(" @ "));
//         sessionName = userID + "#$" + date + " @ " + name + ".session";
//         sessionName = sessionName.replace(":", "_").replace(":", "_");

//         $.ajax({
//           type: "POST",
//           url: "./cgi-bin/SessionRemove.py",
//           data: {
//             userDirectory: JSON.stringify(userDirectory),
//             sessionName: JSON.stringify(sessionName),
//           },
//           success: function (msg) {
//             var status = msg["status"];

//             if (status == "yes") {
//               alert("Session deleted successfully.");

//               getListOfSessions("first");
//             }
//             if (status == "no") {
//               alert("There was no session to be deleted!");
//             }
//           },
//           error: function (msg) {
//             alert("Error in deleting the session!");
//           },
//         });
//       }
//     } else {
//       alert("Please select a session!");
//     }
//   } else {
//     alert("Nothing to be deleted!");
//   }
// }

/**
 * Remove all zip files in the user directory
 */
// function removeZip() {
//     $.ajax({
//       type: "POST",
//       url: "./cgi-bin/deleteZip.py",
//       data: { userDirectory: JSON.stringify(userDirectory) },
//       async: false,
//       success: function (msg) {},
//       error: function (msg) {
//         alert("Error1 in removing zip files!");
//       },
//     });
//   }

/**
 * Checks if the file exists in the user directory
 * @param fileName = file name
 * @return true if exists
 */
// function checkFileExists(fileName) {
//     var result = false;
  
//     $.ajax({
//       type: "POST",
//       url: "./cgi-bin/downloadCheck.py",
//       data: {
//         userDirectory: JSON.stringify(userDirectory),
//         fileName: JSON.stringify(fileName),
//       },
//       async: false,
//       success: function (msg) {
//         var status = msg["status"];
  
//         if (status == "yes") {
//           result = true;
//         }
//       },
//       error: function (msg) {
//         alert("Error1 in downloading the cluster!");
//       },
//     });
  
//     return result;
//   }

/*
 * @param name = name of the session
 * Save the current session of the user.
 */
// function callSaveSession(sessionName) {
//     saveLog("callSaveSession");
  
//     //get note of the sessions
//     if (
//       sessionDescription !=
//       "This session was saved automatically before reclustering."
//     ) {
//       sessionDescription = $("#sessionNote").val();
//     }
  
//     //for no comment case
//     if (sessionDescription == null) {
//       sessionDescription = "";
//     }
  
//     //clear notes
//     $("#sessionNote").val("");
  
//     var tempRemovedDocuments = JSON.stringify(removedDocuments);
  
//     var currentdate = new Date();
//     currentdate =
//       twoDigitNumber(currentdate.getDate()) +
//       " " +
//       twoDigitNumber(currentdate.getMonth() + 1) +
//       " " +
//       currentdate.getFullYear() +
//       " " +
//       twoDigitNumber(currentdate.getHours()) +
//       "_" +
//       twoDigitNumber(currentdate.getMinutes()) +
//       "_" +
//       twoDigitNumber(currentdate.getSeconds());
  
//     var fileName = userID + "#$" + currentdate + " @ " + sessionName;
//     var sessionValue = sessionName + " @ " + currentdate;
  
//     //get the new list of cluster words
//     clusterWords = getNewClusterWords();
  
//     $.ajax({
//       type: "POST",
//       url: "./cgi-bin/SessionSave.py",
//       async: true,
//       data: {
//         fileName: JSON.stringify(fileName),
//         userDirectory: JSON.stringify(userDirectory),
//         clusterWords: JSON.stringify(clusterWords),
//         clusterKeyTerms: JSON.stringify(clusterKeyTerms),
//         clusterDocuments: JSON.stringify(clusterDocuments),
//         clusterCloud: JSON.stringify(clusterCloud),
//         termClusterData: JSON.stringify(termClusterData),
//         termClusterDataString: JSON.stringify(termClusterDataString),
//         documentClusterData: JSON.stringify(documentClusterData),
//         removedDocuments: JSON.stringify(tempRemovedDocuments),
//         gravity: JSON.stringify(gravity),
//         linkDistance: JSON.stringify(linkDistance),
//         cosineDistance: JSON.stringify($("#slider1").slider("value") / 100),
//         documentsName: JSON.stringify(documentsNameString),
//         documentDocumentSimilarity: JSON.stringify(
//           documentDocumentSimilarityString
//         ),
//         termDocumentSimilarity: JSON.stringify(termDocumentSimilarityString),
//         sessionDescription: JSON.stringify(sessionDescription),
//         silhouette: JSON.stringify(silhouette),
//         documentClusterDataString: JSON.stringify(documentClusterDataString),
//       },
//       success: function (msg) {
//         var status = msg["status"];
  
//         if (status == "yes") {
//           sessionDescription = "";
//           alert("Session saved successfully.");
  
//           //select the latest session
//           sessionValue = sessionValue.replace("_", ":").replace("_", ":");
//           getListOfSessions("first");
//         }
//         if (status == "no") {
//           alert("Error1 in saving the session!");
//         }
//         if (status == "error") {
//           alert("Error3 in saving the session!");
//         }
//       },
//       error: function (msg) {
//         alert("Error2 in saving the session!");
//       },
//     });
//   }

/*
 * Delete the selected session.
 */
// function deleteSession() {
//     saveLog("deleteSession");
  
//     if (userID != "") {
//       var sessionName = $("#session_select").val();
  
//       if (sessionName != null) {
//         var confirmed = confirm("Are you sure about deleting this session?");
  
//         if (confirmed) {
//           var date = sessionName
//             .substring(sessionName.indexOf(" @ ") + 3)
//             .replace("_", ":")
//             .replace("_", ":");
//           var name = sessionName.substring(0, sessionName.indexOf(" @ "));
//           sessionName = userID + "#$" + date + " @ " + name + ".session";
//           sessionName = sessionName.replace(":", "_").replace(":", "_");
  
//           $.ajax({
//             type: "POST",
//             url: "./cgi-bin/SessionRemove.py",
//             data: {
//               userDirectory: JSON.stringify(userDirectory),
//               sessionName: JSON.stringify(sessionName),
//             },
//             success: function (msg) {
//               var status = msg["status"];
  
//               if (status == "yes") {
//                 alert("Session deleted successfully.");
  
//                 getListOfSessions("first");
//               }
//               if (status == "no") {
//                 alert("There was no session to be deleted!");
//               }
//             },
//             error: function (msg) {
//               alert("Error in deleting the session!");
//             },
//           });
//         }
//       } else {
//         alert("Please select a session!");
//       }
//     } else {
//       alert("Nothing to be deleted!");
//     }
//   }

/*
 * Get the list of sessions (the name of the sessions).
 * @param sessionIndex = index of session that should be selected
 * @return the lis of sessions
 */
// function getListOfSessions(sessionIndex) {
//     sessions = [];
//     sessionsDescription = [];
  
//     $.ajax({
//       type: "POST",
//       url: "./cgi-bin/SessionList.py",
//       data: { userDirectory: JSON.stringify(userDirectory) },
//       async: false,
//       success: function (msg) {
//         var status = msg["status"];
  
//         if (status == "yes") {
//           sessions = msg["sessions"];
//           sessionsDescription = msg["sessionDescription"];
//           refreshSessionListBox(sessionIndex);
//         }
//         if (status == "no") {
//           refreshSessionListBox();
//         }
//         if (status == "error") {
//           alert("Error1 in finding the list of sessions!");
//         }
//       },
//       error: function (msg) {
//         alert("Error2 in finding the list of sessions!");
//       },
//     });
//   }

/*
 * load session
 * @param sessionName = the name of session to be loaded
 */
// function loadSession(sessionName) {
//   saveLog("loadSession");

//   //change cursor
//   $("body").css("cursor", "wait");

//   //clear screen
//   clearScreen();

//   //remove zip files
//   // removeZip();

//   sessionName = sessionName.replace(":", "_").replace(":", "_");

//   sessionName = userID + "#$" + sessionName + ".session";

//   $.ajax({
//     type: "POST",
//     url: "./cgi-bin/SessionLoad.py",
//     cache: false,
//     traditional: true,
//     data: {
//       userDirectory: JSON.stringify(userDirectory),
//       sessionName: JSON.stringify(sessionName),
//     },
//     success: function (msg) {
//       $("body").css("cursor", "auto");

//       var status = msg["status"];

//       if (status == "no") {
//         alert("Such session does not exists!");
//       } else if (status == "error") {
//         alert("Error in retrieving the session!");
//       } else if (status == "yes") {
//         clearScreen();

//         //load session data;
//         var data = JSON.parse(msg["data"]);

//         clusterWords = data.clusterWords; //the name and the key terms of clusters
//         clusterKeyTerms = data.clusterKeyTerms; //the key terms of clusters are here
//         clusterDocuments = data.clusterDocuments; //the list of documents of cluster
//         clusterCloud = data.clusterCloud; //the cloud terms of cluster
//         termClusterData = data.termClusterData; //the term cluster data
//         termClusterDataString = data.termClusterDataString; //the string of the term cluster data (for changing it later)
//         documentClusterData = data.documentClusterData; //the document cluster data
//         documentClusterDataString = data.documentClusterDataString; //the string of the documnet cluster data (for changing it later)
//         silhouette = data.silhouette; //silhouette
//         gravity = data.gravity;
//         linkDistance = data.linkDistance;
//         var cosineDistance = data.cosineDistance;
//         json2arrayRemovedDocuments(data.removedDocuments);

//         //load note of user
//         $("#sessionNote").val(data.sessionDescription);

//         //for list of all terms of the collection
//         // create request object
//         var asyncRequest = new XMLHttpRequest();
//         // asyncRequest.open(
//         //   "POST",
//         //   "./" + userID + "/" + "out" + userID + ".Terms",
//         //   false
//         // );
//         // asyncRequest.send(); // send the request

//         asyncRequest.open("POST", "./cgi-bin/Terms.py", false);
//         asyncRequest.setRequestHeader(
//           "Content-Type",
//           "application/x-www-form-urlencoded"
//         );
//         asyncRequest.send("userID=" + encodeURIComponent(userID));

//         // allWords = d3.csv.parse(asyncRequest.responseText);
//         allWords = asyncRequest.responseText.split("\n"); // .split("\r\n")

//         //load clusters
//         for (var i = 0; i < clusterWords.length; i++) {
//           //create cluster
//           createCluster(clusterWords[i].cluster);

//           //add terms to the cluster
//           for (var j = 0; j < clusterWords[i].words.length; j++) {
//             x = document.getElementById(clusterWords[i].cluster);

//             $(x.getElementsByClassName("sortable")).append(
//               "<li class='ui-state-default ui-sortable-handle' onmousedown=\"wordMouseDown(event)\"><span class='terms'>" +
//                 clusterWords[i].words[j].word +
//                 "</span></li>"
//             );
//           }
//         }

//         //get the list of documents name
//         documentsNameString = data.documentsName;
//         documentsName = documentsNameString.split("\n"); // .split("\r\n")

//         //get document-document similarity matrix
//         documentDocumentSimilarityString = data.documentDocumentSimilarity;
//         var temp = documentDocumentSimilarityString.split("\n"); // .split("\r\n")
//         for (var i = 0; i < temp.length; i++) {
//           if (temp[i].length > 0) {
//             documentDocumentSimilarity[i] = temp[i].split(",");
//           }
//         }

//         //get term-document matrix
//         termDocumentSimilarityString = data.termDocumentSimilarity;
//         var temp = termDocumentSimilarityString.split("\n"); // .split("\r\n")
//         for (var i = 0; i < temp.length; i++) {
//           if (temp[i].length > 0) {
//             termDocumentSimilarity[i] = temp[i].split(",");
//           }
//         }

//         //get general view graph
//         // generalViewGraph = getGeneralViewGraph(0.97);

//         //load General View
//         // generalViewLoader(cosineDistance);

//         //set the sliders value
//         $("#slider1").slider("value", parseInt(cosineDistance * 100));
//         $("#slider2").slider("value", parseInt(linkDistance));
//         $("#slider3").slider("value", parseInt(gravity * 100));
//         $("#slider1_Textbox").val(parseInt(cosineDistance * 100));
//         $("#slider2_Textbox").val(parseInt(linkDistance));
//         $("#slider3_Textbox").val(parseInt(gravity * 100));

//         //refresh tree view
//         refreshTreeView();

//         //select the first cloud
//         clusterClicked(clusterWords[0].cluster);

//         $("#slider1").slider("enable");
//         $("#slider2").slider("enable");
//         $("#slider3").slider("enable");
//         $("#slider1_Textbox").removeAttr("disabled");
//         $("#slider2_Textbox").removeAttr("disabled");
//         $("#slider3_Textbox").removeAttr("disabled");

//         //show silhouette
//         // $("#silhouette").append("Silhouette: " + silhouette);

//         $("body").css("cursor", "auto");
//       }
//     },
//     error: function (msg) {
//       $("body").css("cursor", "auto");
//       alert("Error in retrieving the session!");
//     },
//   });
// }

// ################################################################################
// # Peach - Computational Intelligence for Python
// # Jose Alexandre Nalon
// #
// # This file: fuzzy/cmeans.py
// # Fuzzy C-Means algorithm
// ################################################################################

// # Doc string, reStructuredText formatted:
// __doc__ = """
// Fuzzy C-Means

// Fuzzy C-Means is a clustering algorithm based on fuzzy logic.

// This package implements the fuzzy c-means algorithm for clustering and
// classification. This algorithm is very simple, yet very efficient. From a
// training set and an initial condition which gives the membership values of each
// example in the training set to the clusters, it converges very fastly to crisper
// sets.

// The initial conditions, ie, the starting membership, must follow some rules.
// Please, refer to any bibliography about the subject to see why. Those rules are:
// no example might have membership 1 in every class, and the sum of the membership
// of every component must be equal to 1. This means that the initial condition is
// a fuzzy partition of the universe.
// """


// ################################################################################
// import numpy
// import numbers
// from numpy import dot, array, sum, zeros, outer, any
// from scipy.spatial.distance import cdist

// ################################################################################
// # Fuzzy C-Means class
// ################################################################################
// class FuzzyCMeans(object):
    
    
//     def __init__(self, training_set, k, m=2.0, distance='euclidean', userU = -1, imax = 25, emax = 0.01):
        
//         self.__x = training_set
//         self.__k = k
//         self.m = m
//         self.dist = distance
//         self.userU = userU
//         self.imax = imax
//         self.emax = emax
       
        
//         if (isinstance(userU, numbers.Number)):
//             self.__mu = self.initializeFCM()
//         else:
//             _, N = userU.shape
//             index = numpy.where(userU > 0);
//             for j in range(index[1].size):
//                 userU[:, index[1][j]] = userU[:, index[1][j]]/sum(userU[:, index[1][j]])
//             self.__mu = userU
            
//         self.__obj = 0
        
// 	#self.__c, self.__obj = self.centers()


//     def __getc(self):
//         return self.__c
    
//     def __setc(self, c):
//         self.__c = array(c).reshape(self.__c.shape)
        
//     c = property(__getc, __setc)
    

//     def __getmu(self):
//         return self.__mu
    
//     mu = property(__getmu, None)
    

//     def __getx(self):
//         return self.__x
    
//     x = property(__getx, None)
    
//     def initializeFCM(self):
        
//         x = self.__x
        
//         N, _ = x.shape
        
//         U = numpy.random.random((self.__k, N))
        
//         for j in range(N):
//             U[:,j] = U[:,j]/sum(U[:,j])
            
//         return U
    
//     def centers(self):
        
//         x = self.__x
        
//         _, M = x.shape
        
//         mm = self.__mu ** self.m
        
//         tempRep = numpy.dot(numpy.ones((M,1)), numpy.asanyarray([numpy.sum(mm, axis=1)]))
        
        
//         c = dot(mm, self.__x) / tempRep.T
        
        
//         self.__c = c
        
        
        
//         tempDist = cdist(c, x, self.dist) #self.dist 'cosine'
//         dist = tempDist**2.0
//         obj = numpy.sum((dist**2.0)*mm)
//         self.__obj = obj
        
//         return self.__c, self.__obj

//     def membership(self):
        
//         x = self.__x
//         c = self.__c
//         N, _ = x.shape
//         k = self.__k
//         r = numpy.zeros((k, N))      # r will become mu
// 	    tempDist = cdist(c, x, self.dist) #self.dist 'cosine'
//         dist = tempDist**2.0
//         temp = dist**(-2.0/(self.m-1))
//         tempSum = numpy.asanyarray([numpy.sum(temp, axis=0)])
//         r = temp/(numpy.dot(numpy.ones((k,1)), tempSum))
        
//         self.__mu = r
//         return self.__mu

//     def step(self):
//         '''
//         This method runs one step of the algorithm. It might be useful to track
//         the changes in the parameters.

//         :Returns:
//           The norm of the change in the membership values of the examples. It
//           can be used to track convergence and as an estimate of the error.
//         '''
//         #old = self.__mu
//         old = self.__obj
//         self.centers()
//         self.membership()
//         return numpy.abs(self.__obj - old)
//         #return sum(self.__mu - old)**2.

//     def __call__(self):
//         '''
//         The ``__call__`` interface is used to run the algorithm until
//         convergence is found.

//         :Parameters:
//           emax
//             Specifies the maximum error admitted in the execution of the
//             algorithm. It defaults to 1.e-10. The error is tracked according to
//             the norm returned by the ``step()`` method.
//           imax
//             Specifies the maximum number of iterations admitted in the execution
//             of the algorithm. It defaults to 20.

//         :Returns:
//           An array containing, at each line, the vectors representing the
//           centers of the clustered regions.
//         '''
// 	error = 1.0
// 	emax = self.emax
// 	imax = self.imax

//         i = 0
//         while error > emax and i < imax:
//             error = self.step()
            
//             if not(isinstance(self.userU, numbers.Number)):
//                 mu = self.__mu
//                 k, N = mu.shape
//                 index = numpy.where(self.userU > 0);
//                 for j in range(index[1].size):
//                     mu[:,index[1][j]] = 0
//                 for j in range(index[1].size):
//                     mu[index[0][j],index[1][j]] = self.userU[index[0][j],index[1][j]]
//                 for j in range(index[1].size):
//                     mu[:, index[1][j]] = mu[:, index[1][j]]/sum(mu[:, index[1][j]])
//                 self.__mu = mu
//             #print "obj: ", self.__obj
//             i = i + 1
//         return self.c


// ################################################################################
// # Test.
// if __name__ == "__main__":
//     pass


// /*
//  * clear the screen.
//  */
// function clearScreen() {
//   //clear previous data
//   tsneResult = new Array();

//   $("#forceSilhouette_label").html("");

//   clusterWords = ""; //the name and the key terms of clusters
//   clusterKeyTerms = ""; //the key terms of clusters are here
//   clusterDocuments = ""; //the list of documents of cluster
//   clusterCloud = ""; //the cloud terms of cluster
//   termClusterData = ""; //the term cluster data
//   termClusterDataString = ""; //the string of the term cluster data (for changing it later)
//   documentClusterData = ""; //the document cluster data
//   documentClusterDataString = ""; //the string of the documnet cluster data (for changing it later)
//   allWords = ""; //all words

//   $("#panel4_1").html("");
//   $("#doc_content").html("");
//   $("#doc_select").html("");
//   $("#DocumentClusterView").html("");
//   $("#barcharts").html("");
//   $("#selectable").html("");
//   $("#TermClusterView").html("");
//   $("#panel8_2").html("");
//   $("#general_view1").html("");
//   $("#general_view2").html("");
//   $("#TsneSilhouette_label").html("");

//   $("#slider1").slider("disable");
//   $("#slider2").slider("disable");
//   $("#slider3").slider("disable");
//   $("#slider1_Textbox").attr("disabled", "disabled");
//   $("#slider2_Textbox").attr("disabled", "disabled");
//   $("#slider3_Textbox").attr("disabled", "disabled");

//   $.jstree.destroy(); //clear tree view

//   // $("#silhouette").html("");
// }

/*
 * Send the desired terms of the users to the server in order to reclustering.
 */
// function SendData2Server() { ///////////////
//   //save session before
//   sessionDescription =
//     "This session was saved automatically before reclustering.";
//   callSaveSession("AutoSave");

//   clusterNumber = document.getElementsByClassName("cluster").length;

//   if (clusterNumber < 2) {
//     userU = -1;
//     alert("Your desired number of clusters should be at least 2!");
//   } else {
//     userU = +1;
//     serverData = new Array();

//     var confirmed = confirm(
//       "Your desired number of clusters is " + clusterNumber
//     );
//     if (confirmed) {
//       var clusters = document.getElementsByClassName("cluster");

//       for (var i = 0; i < clusters.length; i++) {
//         var clusterName = $(clusters[i]).attr("id");
//         var terms = $(
//           document
//             .getElementById(clusterName)
//             .getElementsByClassName("sortable")
//         ).children();

//         serverClusetrName[i] = clusterName;
//         serverData[i] = new Array();
//         for (var j = 0; j < terms.length; j++) {
//           serverData[i][j] = $(terms[j]).text();
//         }
//       }

//       clearScreen();
//       callServer();
//     }
//   }
// }

/**
 * Get Silhouette of force layout.
 */
// function forceSilhouette() {
//   saveLog("forceSilhouette");

//   force2.stop();

//   $("#forceSilhouette_label").html("");

//   var nodes = $(".node2");

//   var forceResult = new Array();
//   var forceLables = new Array();

//   for (var i = 0; i < nodes.length; i++) {
//     forceResult[i] = new Array();
//     forceResult[i][0] = parseFloat($(nodes[i]).attr("cx"));
//     forceResult[i][1] = parseFloat($(nodes[i]).attr("cy"));

//     forceLables[i] = $(nodes[i]).css("fill");
//   }

//   // getForceSilhouette(forceResult, forceLables);
// }
/*
 * Get  force Silhouette
 * @param forceResult =  x and y dimensions
 * @param forceLables = labels of documents
 */
// function getForceSilhouette(forceResult, forceLables) {
//   $.ajax({
//     type: "POST",
//     url: "./cgi-bin/tsneSilhouette.py",
//     data: {
//       tsneResult: JSON.stringify(forceResult),
//       tsneLables: JSON.stringify(forceLables),
//     },
//     success: function (msg) {
//       var status = msg["status"];

//       if (status == "yes") {
//         var forceSilhouette = eval(msg["TsneSilhouette"]);
//         forceSilhouette = forceSilhouette.toFixed(4);

//         //show the tsne Silhouette
//         $("#forceSilhouette_label").html(
//           "Force layout Silhouette: " + forceSilhouette
//         );
//       }
//       if (status == "no") {
//         alert("Error1 in getting Force Silhouette!");
//       }
//       if (status == "error") {
//         alert("Error2 in getting Force Silhouette!");
//       }
//     },
//     error: function (msg) {
//       alert("Error3 in getting Force Silhouette!");
//     },
//   });
// }
//write a function to make ajax request to explanation.py
/**
 * Highlight documents that have selected terms
 * @param words = the selected words
 */
var docsHighlight = new Array(); //Highlighted docs
// function highlightDocuments(words) {
//   saveLog("highlightDocuments");

//   docsHighlight = new Array();

//   for (var i = 0; i < words.length; i++) {
//     for (var j = 0; j < termDocumentSimilarity.length; j++) {
//       var docScore = 0.0;
//       docScore = termDocumentSimilarity[j][allWords.indexOf(words[i])];
//       if (docScore > 0) {
//         docsHighlight[documentsName[j]] = true;
//       }
//     }
//   }

//   //change the stroke of corresponding nodes (docs) in general view graph
//   // node.style("stroke", function(o) {
//   //   if(o.na == $(doc_select).val())
//   //   {
//   //     return "red";
//   //   }
//   //   else if(docsHighlight[o.na]) {
//   //     return "blue";
//   //   }
//   //   else {
//   //     return "#ccc";
//   //   }
//   // })

//   // node.style("stroke-width", function(o) {
//   //   if(docsHighlight[o.na] || o.na == $(doc_select).val()) {
//   //     return "2px";
//   //   }
//   //   else {
//   //     return "0.5px";
//   //   }
//   // })

//   //change the opacity of corresponding nodes (docs) and links in general view graph
//   node.style("opacity", function (o) {
//     return docsHighlight[o.na] ? 1 : highlight_trans;
//   });

//   link.style("opacity", function (o) {
//     return docsHighlight[o.source.na] && docsHighlight[o.target.na] ? 1 : 0;
//   });

//   node2.style("opacity", function (o) {
//     return docsHighlight[o.na] ? 1 : highlight_trans;
//   });

//   link2.style("opacity", function (o) {
//     return docsHighlight[o.source.na] && docsHighlight[o.target.na] ? 1 : 0;
//   });
// }

/**
 * Show the content of the selected file in the cluster tree view
 * @param fileName = the name of selected file
 */
// function fileClicked(fileName) {
//   console.log("fileClicked", fileName);
//   <li 
//     role="none" 
//     data-jstree="{&quot;icon&quot;:&quot;img/pdf.gif&quot;}" 
//     onclick="fileClicked(this)" 
//     id="j2_3" class="jstree-node context-menu-three box menu-1 jstree-leaf">
//       <i class="jstree-icon jstree-ocl" role="presentation"></i>
//       <a class="jstree-anchor jstree-clicked" href="#" tabindex="-1" role="treeitem" aria-selected="true" aria-level="3" id="j2_3_anchor">
//       <i class="jstree-icon jstree-themeicon jstree-themeicon-custom" role="presentation" style="background-image: url(&quot;img/pdf.gif&quot;); background-position: center center; background-size: auto;">
//         </i>paper2.txt</a>
//         </li>
//   ////////////////////////////////////////////////////////////////////////////////////////  ///////////////////////////
//   //// /////////// Add a dialog box maybe to show the selected document in the cluster ree //////////////////////////////
//   ////////////////////////////////////////////////////////////////////////////////////////  ///////////////////////////
//   // document.getElementById("doc_content").innerHTML = "";
//   // loadDoc($(fileName).text());
//   // // highlightDocGeneralView($(fileName).text());
//   // createTermClusterChart();
//   // //show the paralel cordinator view
//   // var words = new Array(1);
//   // var colors = {};
//   // words[0] = $(fileName).text();
//   // colors[words[0]] = $("#" + getSelectedClusterID() + " p").css(
//   //   "background-color"
//   // ); //"Blue";
//   // paralelCordinator(
//   //   documentClusterData,
//   //   "#panel6",
//   //   words,
//   //   "#DocumentClusterView",
//   //   colors
//   // );
//   // //change the selected list of documents
//   // var docSelect = document.getElementById("doc_select");
//   // for (var i = 0; i < docSelect.options.length; i++) {
//   //   if (docSelect.options[i].innerHTML == $(fileName).text()) {
//   //     docSelect.selectedIndex = i;
//   //     break;
//   //   }
//   // }
// }

/**
 * For cluster tooltip
 * @param clusterName = cluster ID
 */
// function clusterToolTip(clusterName) {
//   $("#" + clusterName).qtip({
//     // Content
//     content: {
//       title: "Cluster Name: " + clusterName,
//       text: "Number of Documents: " + numberOfDocumnets(clusterName),
//     },

//     // Positioning
//     position: {
//       at: "bottom center",
//       my: "top center",
//     },

//     // Styles
//     style: {
//       classes: "qtip-rounded qtip-shadow",
//     },
//   });
// }

/**
 * Rename Cluster Name in Graph
 * @param oldName = old name of cluster
 * @param oldName = new name of cluster
 */
// function renameClusterNameInGraph(oldName, newName) {
//   var names = $(".clusterNameInGraph");

//   //rename the cluster name in tooltip of node
//   node.attr("data-hasqtip", function (d) {
//     $(this).qtip({
//       content: {
//         text:
//           '<strong>Document name:</strong><br><u class="hyperLink" onclick="showDocumentPDF($(this).text())">' +
//           d.na +
//           "</u><br><br><strong>List of clusters name:</strong><br>" +
//           createListOfDocumentClustersName(
//             renameCLusterNameInToolTip(d.cl, oldName, newName),
//             d.na
//           ),
//       },
//       hide: {
//         fixed: true,
//         delay: 700,
//       },
//       show: {
//         delay: 700,
//       },
//       style: {
//         classes: "qtip-rounded qtip-shadow",
//       },
//       position: {
//         my: "center right",
//         at: "center left",
//       },
//     });
//   });

//   node2.attr("data-hasqtip", function (d) {
//     $(this).qtip({
//       content: {
//         text:
//           '<strong>Document name:</strong><br><u class="hyperLink" onclick="showDocumentPDF($(this).text())">' +
//           d.na +
//           "</u><br><br><strong>List of clusters name:</strong><br>" +
//           createListOfDocumentClustersName(
//             renameCLusterNameInToolTip(d.cl, oldName, newName),
//             d.na
//           ),
//       },
//       hide: {
//         fixed: true,
//         delay: 700,
//       },
//       show: {
//         delay: 700,
//       },
//       style: {
//         classes: "qtip-rounded qtip-shadow",
//       },
//       position: {
//         my: "center right",
//         at: "center left",
//       },
//     });
//   });

//   //rename the cluster name in generalViewGraph
//   for (var i = 0; i < generalViewGraph.nodes.length; i++) {
//     var newClusters = "";
//     var clusters = generalViewGraph.nodes[i].cl.split(",");

//     for (var j = 0; j < clusters.length; j++) {
//       var temp = "";
//       if (clusters[j] == oldName) {
//         temp = newName;
//       } else {
//         temp = clusters[j];
//       }

//       if (newClusters == "") {
//         newClusters = temp;
//       } else {
//         newClusters += "," + temp;
//       }
//     }

//     generalViewGraph.nodes[i].cl = newClusters;
//   }

//   for (var i = 0; i < generalViewGraph2.nodes.length; i++) {
//     var newClusters = "";
//     var clusters = generalViewGraph2.nodes[i].cl.split(",");

//     for (var j = 0; j < clusters.length; j++) {
//       var temp = "";
//       if (clusters[j] == oldName) {
//         temp = newName;
//       } else {
//         temp = clusters[j];
//       }

//       if (newClusters == "") {
//         newClusters = temp;
//       } else {
//         newClusters += "," + temp;
//       }
//     }

//     generalViewGraph2.nodes[i].cl = newClusters;
//   }
// }
// #create documents relatedness to each clusters (comparing the document vector with clusters centroid)
// # documentMembers = "name"
// # for i in range(len(documentClustersHash)):
// #     if len(clusterNames) > 0:
// #         documentMembers += "," + clusterNames[i]
// #     else:
// #         documentMembers += ",cluster" + str(i)
// # for documentIndex, documentName in enumerate(documentNames):
// #     documentVector = document_term_matrix[documentIndex,:]
// #     documentMembers += "\n" + documentName
// #     for clusterIndex, clusterCenter in enumerate(clusterer.cluster_centers_):
// #         try:
// #             documentMembers += "," + str((1 - cosine(clusterCenter,documentVector))*100)
// #         except:
// #             documentMembers += "," + str(0)
// # documentMembersFile = open(userDirectory + "documentMembers", 'w')
// # documentMembersFile.write(documentMembers)
// # documentMembersFile.close()


// # #algorithm config. parameters
// # termPercentileInit = 10.0 * math.pow(2, 2 * (1 - confidenceUser / 50.0)) # upper bound for the number of terms of each cluster after expansion (default 10, by confidencUser 50)- the lower the more slave to user comands 
// # documentPercentileInit = 20.0 * math.pow(2, 2 * (1 - confidenceUser / 50.0))  # upper bound for the number of documents of each cluster after expansion (default 20, by confidencUser 50)- the lower the more slave to user comands 
// # cmeansWords = 5 #get top 5 term of cmeans
// # numberOfTermsOfCluster = 100# at most top 100 words for each cluster will be sent to the user (terms less than avg are filterd).

// # # read document-term matrix
// # document_term_matrix = np.asarray(utility.read_term_document_matrix(userDirectory + "out" + userID + ".Matrix"),
// #                                   dtype=float)
// # # read list of document name (name of the rows of the document-term matrix)
// # documentNames, documentNamesIndex = utility.read_single_column_data(userDirectory + "fileList")

// # # read list of terms (name of the columns of the document-term matrix)
// # termNames, termNamesIndex = utility.read_single_column_data(userDirectory + "out" + userID + ".Terms")

// # clusterTerms = []
// # clusterNames = []
// # if firstTime == +1:#get users terms
// #     clusterNames = eval(form.getvalue('serverClusterName'))
// #     clusterTerms = eval(form.getvalue('serverData'))

// # if firstTime == -1:#if it is the first time, get top 5 terms of each cluster from cmeans
// #     cntr, u, u0, d, jm, p, fpc = bestCmeans.cmeans(document_term_matrix, c=numberOfClusters, m=1.1, error=0.005, maxiter=50, init=None)
// #     for cluster in u:
// #         temp = []
// #         for i in range(0, cmeansWords):
// #             temp.append(termNames[cluster.argmax()])
// #             cluster[cluster.argmax()] = -1
// #         clusterTerms.append(temp)    

// # #calculate centroid of selected terms
// # termCentroids = np.zeros((len(clusterTerms), len(document_term_matrix)))
// # for index, clusterTerm in enumerate(clusterTerms):
// #     center = np.zeros(len(document_term_matrix))
// #     for term in clusterTerm:
// #         center = center + document_term_matrix[:,termNamesIndex[term]]
// #     center = center / len(clusterTerm)
// #     termCentroids[index] = center

// # #expand terms using Cosine distance over the column of document-term matrix
// # termCentroidCosine = np.zeros((len(clusterTerms), len(termNames)))
// # for index, centroid in enumerate(termCentroids):
// #     for termIndex in range(0, len(termNames)):
// #         try:
// #             termCentroidCosine[index, termIndex] = cosine(centroid, document_term_matrix[:,termIndex])
// #         except:
// #             termCentroidCosine[index, termIndex] = 1

// # termPercentile = termPercentileInit * len(termNames) / 100# upper bound for the number of terms of each cluster
// # seedDocumentsTerms = np.zeros((len(clusterTerms), len(termNames)))
// # # tempTermCentroidCosine = termCentroidCosine
// # tempTermCentroidCosine = np.zeros((len(clusterTerms), len(termNames)))
// # tempTermCentroidCosine[:] = termCentroidCosine
// # for index, center in enumerate(tempTermCentroidCosine):
// #     average = np.average(center)
// #     minDistance = center.min()
// #     counter = 0
// #     while minDistance < average:
// #         seedDocumentsTerms[index, center.argmin()] = center.min()
// #         counter += 1
// #         if counter > termPercentile:
// #             break
// #         minDistance = center.min()
// #         center[center.argmin()] = 2

// #select documents related to the selected terms and calculate the centroid of documents
// # seedDocumentsTermsCosine = np.zeros((len(clusterTerms), len(documentNames)))
// # for index, centroid in enumerate(seedDocumentsTerms):
// #     for document_index in range(0, len(documentNames)):
// #         try:
// #             seedDocumentsTermsCosine[index, document_index] = cosine(centroid, document_term_matrix[document_index,:])
// #         except:
// #             seedDocumentsTermsCosine[index, document_index] = 1

// # documentPercentile = documentPercentileInit * len(documentNames) / 100# upper bound for the number of terms of each cluster
// # seedDocuments = np.zeros((len(clusterTerms), len(termNames)))
// # for index, center in enumerate(seedDocumentsTermsCosine):
// #     average = np.average(center)
// #     minDistance = center.min()
// #     counter = 0
// #     while minDistance < average:
// #         seedDocuments[index] = seedDocuments[index] + document_term_matrix[center.argmin(),:]
// #         counter += 1
// #         if counter > documentPercentile:
// #             break
// #         minDistance = center.min()
// #         center[center.argmin()] = 2
//     # seedDocuments[index] = seedDocuments[index] / counter ///////////////////

// #run kmeans
// # clusterer = KMeans(n_clusters=numberOfClusters, init=seedDocuments, n_init=1) //////////////
// # clusterer = KMeans(n_clusters=numberOfClusters, init=seedDocuments, n_init=1)
// # clusterer = KMeans(n_clusters=numberOfClusters, n_init=1)
// # labels_pred = clusterer.fit_predict(document_term_matrix)

// #calculate average silhouette
// # AVG_silhouette = metrics.silhouette_score(document_term_matrix, labels_pred, metric='cosine')

// # #create documents of clusters list (list of assigned documents to each cluster)
// # documentClustersHash = {}
// # for index, label in enumerate(labels_pred):
// #     if not label in documentClustersHash:
// #         documentClustersHash[label] = documentNames[index]
// #     else:
// #         documentClustersHash[label] += "," + documentNames[index]

// # documentClusters = ""
// # for value in documentClustersHash.values():
// #     documentClusters += value + "\n"
// # documentClustersFile = open(userDirectory + "documentClusters",'w')
// # documentClustersFile.write(documentClusters)
// # documentClustersFile.close()

// # documentClustersArray = []
// # for value in documentClustersHash.values():
// #     docs = value.split(',')
// #     tempArray = []
// #     for index, doc in enumerate(docs):
// #         tempArray.append(doc)
// #     documentClustersArray.append(tempArray)



// # create list of terms of clusters (list of assigned terms to each cluster - sorted) - cosine
// # termClusters = ""
// # termClustersArray = []
// # tempTermCentroidCosine[:] = termCentroidCosine
// # for index, center in enumerate(tempTermCentroidCosine):
// #     average = np.average(center)
// #     minDistance = center.min()
// #     termClusters += termNames[center.argmin()]
// #     counter = 0
// #     tempArray = []
// #     tempArray.append(termNames[center.argmin()])
// #     while minDistance < average:
// #         counter += 1
// #         if counter >= numberOfTermsOfCluster:
// #             break
// #         center[center.argmin()] = 2
// #         termClusters += "," + termNames[center.argmin()]
// #         tempArray.append(termNames[center.argmin()])
// #         minDistance = center.min()
// #     termClusters += "\n"
// #     termClustersArray.append(tempArray)
// # termClustersFile = open(userDirectory + "termClusters", 'w')
// # # termClustersFile.write(termClusters)
// # termClustersFile.close()

// #create terms relatedness to each clusters (comparing the centroid of terms)
// # termMembers = "name"
// # for i in range(len(documentClustersHash)):
// #     if len(clusterNames) > 0:
// #         termMembers += "," + clusterNames[i]
// #     else:
// #         termMembers += ",cluster" + str(i)
// # for termIndex, termName in enumerate(termNames):
// #     termMembers += "\n" + termName
// #     for index, center in enumerate(termCentroidCosine):
// #         termMembers += "," + str((1 - center[termIndex])*100)
// # termMembersFile = open(userDirectory + "termMembers", 'w')
// # termMembersFile.write(termMembers)
// # termMembersFile.close()


// if (key == "AddTerm") {
      //   addTermToCluster($(this).closest("div").attr("id"));
      // }
      
      // if (key == "DeleteCluster") {
      //   clusterDelete($(this).closest("div").attr("id"));
      // }

      // if (key == "ClearTerms") {
      //   clearTerms($(this).closest("div").attr("id"));
      // }

      // if (key == "showNodes") {
      //   showClusterNodes($(this).closest("div").attr("id"));
      // }

      // if (key == "Download") {
      //   downloadCluster($(this).closest("div").attr("id"));
      // }

      // if (key == "ChangeColor") {
      //   clusterColorChange($(this).closest("div").attr("id"));
      // }

            // DeleteCluster: { name: "DeleteCluster", icon: "delete" },
      // ClearTerms: { name: "ClearTerms", icon: "delete" },
      // Download: { name: "Download", icon: "edit" },
      // ChangeColor: { name: "ChangeColor", icon: "edit" },

            // AddTerm: { name: "AddTerm", icon: "edit" },
      // showNodes: { name: "showNodes", icon: "edit" },

      /**
 * Removing a cluster
 * @param clusterName = the name of right clicked cluster
 */
// function clusterDelete(clusterName) {
    // saveLog("clusterDelete");
    // if (clusterName != null) {
    //   if (confirm('Are you sure about deleting "' + clusterName + '"')) {
    //     $("body").css("cursor", "wait");
    //     var selectedCluster = getSelectedClusterID();
    //     //rename the cluster in json data files
    //     //because data are temp it does not need to delele it just
    //     //rename it to a strange name
    //     renameClusterNameInJson(
    //       clusterKeyTerms,
    //       clusterName,
    //       "@!@@@%%@@@@%@@!!!@@"
    //     );
    //     renameClusterNameInJson(clusterCloud, clusterName, "@!@@@%%@@@@%@@!!!@@");
    //     renameClusterNameInJson(clusterWords, clusterName, "@!@@@%%@@@@%@@!!!@@");
    //     renameClusterNameInJson(
    //       clusterDocuments,
    //       clusterName,
    //       "@!@@@%%@@@@%@@!!!@@"
    //     );
    //     //rename the cluster in csv data files
    //     renameClusterNameInCSV("data2", clusterName, "@!@@@%%@@@@%@@!!!@@");
    //     renameClusterNameInCSV("data1", clusterName, "@!@@@%%@@@@%@@!!!@@");
    //     //clear document view, term view, term cloud and paralel cordinator
    //     //if the selected cluster was removed!
    //     if (clusterName == selectedCluster) {
    //       $("#doc_content").html("");
    //       $("#doc_select").html("");
    //       $("#DocumentClusterView").html("");
    //       $("#barcharts").html("");
    //       $("#selectable").html("");
    //       $("#TermClusterView").html("");
    //       $("#panel8_2").html("");
    //       //change the title colors to defualt
    //       $("#panel2title").css("background-color", "#CCC");
    //       $("#panel3title").css("background-color", "#CCC");
    //       $("#panel4title").css("background-color", "#CCC");
    //       // $("#panel5title").css("background-color", "#CCC");
    //       $("#panel6title").css("background-color", "#CCC");
    //       $("#panel7title").css("background-color", "#CCC");
    //       $("#panel8title").css("background-color", "#CCC");
    //     }
    //     //remove the cluster in cluster view
    //     $("#" + clusterName).remove();
    //     //remove the name of cluster in tree view
    //     refreshTreeView();
    //     //remove cluster from general view graph
    //     removeClusterInGraph(clusterName);
    //     $("body").css("cursor", "auto");
    //   }
    // } else {
    //   alert("Please select the cluster first.");
    //   $("body").css("cursor", "auto");
    // }
//   }
// /**
//  * Removing a cluster from general view graph
//  * @param clusterName = the name of right clicked cluster
//  */
// function removeClusterInGraph(clusterName) {
//     //if no cluster exists
//     var number_of_clusters = $(".cluster").length;
  
//     if (number_of_clusters == 0) {
//       //if no cluster exists
//       generalViewGraph = "";
  
//       $("#general_view1").html("");
  
//       $("#slider1").slider("disable");
//       $("#slider2").slider("disable");
//       $("#slider3").slider("disable");
//       $("#slider1_Textbox").attr("disabled", "disabled");
//       $("#slider2_Textbox").attr("disabled", "disabled");
//       $("#slider3_Textbox").attr("disabled", "disabled");
//       $("#span2").text("");
//       $("#span4").text("");
//     } else {
//       //update the list of removed documents
//       generalViewGraph.nodes.filter(function (n) {
//         var clusters = n.cl.split(",");
//         var newClusters = "";
  
//         if (clusters.length == 1 && clusters[0] == clusterName) {
//           removedDocuments[documentsName.indexOf(n.na)] = true;
//         }
//       });
  
//       //update the generalViewGraph
//       //get general view graph
//       // generalViewGraph = getGeneralViewGraph(0.97);
  
//       //load General View
//       var threshold = $("#slider1").slider("value") / 100;
  
//       // generalViewLoader(threshold);
//     }
//   }


// /**
//  * Open Upload Page.
//  */
// function openUploadPage() {
//       saveLog("openUploadPage");
//       window.open("./upload.html", "_blank");
//     }
// /**
//  * Get the selected text inside of document view
//  * @returns the text of selected text inside the document view
//  */
// function getSelectedText() {
//       var text = "";
//       if (window.getSelection) {
//         text = window.getSelection().toString();
//       } else if (document.selection && document.selection.type != "Control") {
//         text = document.selection.createRange().text;
//       }
    
//       return text.trim();
//     }

// /**
//  * Add new term to the cluster (if a term in key term list double clicked)
//  */

// /**
//  * Add new term to the cluster (if a word in a documnet content double clicked)
//  */



// /**
//  * Clearing the cluster terms
//  * @param item = indicates the clearTerms buttom of which cluster was pressed
//  */
// function clearTerms(item) {
//       // var x;
//       // x = document.getElementsByClassName("cluster");
//       // var i;
//       // for (i = 0; i < x.length; i++) {
//       //     if(x[i].style.borderColor == "rgb(254, 46, 154)")
//       //     {
//       //         $(x[i].getElementsByClassName("sortable")).html("");
//       //     }
//       // }
    
//       // $("#"+  + " sortable").html("");
//       var clusterName = item;
//       var clusterElement = document.getElementById(clusterName);
//       $(clusterElement.getElementsByClassName("sortable")).html("");
//     }
//     var selectedColorInPalette = "";
//     /**
//      * Change cluster color
//      * @param clusterName = name of cluster
//      */
//     function clusterColorChange(clusterName) {
//       saveLog("clusterColorChange");
    
//       selectedColorInPalette = "";
    
//       var statesdemo = {
//         state0: {
//           title: "Select a color:",
//           opacity: 0.3,
//           html: function () {
//             return colorPalette();
//           },
//           buttons: { Cancel: false, Ok: true },
//           focus: 1,
//           submit: function (e, v, m, f) {
//             if (v) {
//               e.preventDefault();
    
//               if (selectedColorInPalette == "") {
//                 alert("Please select a color first!");
//               } else {
//                 //check if there is a cluster with this color or not
//                 if (colorIsSelected(selectedColorInPalette)) {
//                   alert("This color has been selected before!");
//                 } else {
//                   $.prompt.close();
//                   changeClusterColor(clusterName, selectedColorInPalette);
//                 }
//               }
//             } else {
//               $.prompt.close();
//             }
//           },
//         },
//       };
    
//       $.prompt(statesdemo);
//     }
// /**
//  * change the cluster color
//  * @param clusterName = the name of cluster
//  * @param color = new color code
//  */
// function changeClusterColor(clusterName, color) {
//       //change the panel titles if the selected cluster should be recolored
//       if (getSelectedClusterID() == clusterName) {
//         $("#panel2title").css("background-color", color);
//         $("#panel3title").css("background-color", color);
//         $("#panel4title").css("background-color", color);
//         // $("#panel5title").css("background-color", color);
//         $("#panel6title").css("background-color", color);
//         $("#panel7title").css("background-color", color);
//         $("#panel8title").css("background-color", color);
    
//         //change color in document-cluster view
//         var words = new Array(1);
//         var colors = {};
//         words[0] = document.getElementById("doc_select").value;
//         colors[words[0]] = color; //"Blue";
//         paralelCordinator(
//           documentClusterData,
//           "#panel6",
//           words,
//           "#DocumentClusterView",
//           colors
//         );
//       }
    
//       //change the cluster color in clusters panel
//       var oldColor = $("#" + clusterName + " p").css("background-color");
//       $("#" + clusterName + " p").css({ "background-color": color });
    
//       //change the cluster color in general view panel
//       changeClusterColorInGraph(oldColor, color);
//     }
    
//     /**
//  * Change the color of cluster in graph
//  * @param oldColor = old color name
//  * @param color = new color
//  */
// function changeClusterColorInGraph(oldColor, color) {
//       //change the cluster in tooltip of node
//       node.attr("data-hasqtip", function (d) {
//         $(this).qtip({
//           content: {
//             text:
//               '<strong>Document name:</strong><br><u class="hyperLink" onclick="showDocumentPDF($(this).text())">' +
//               d.na +
//               "</u><br><br><strong>List of clusters name:</strong><br>" +
//               createListOfDocumentClustersName(d.cl, d.na) +
//               "</u><br><strong>List of top 5 terms:</strong><br>" +
//               getListOfTermsOfDocument(d.na),
//           },
//           hide: {
//             fixed: true,
//             delay: 700,
//           },
//           show: {
//             delay: 700,
//           },
//           style: {
//             classes: "qtip-rounded qtip-shadow",
//           },
//           position: {
//             my: "center right",
//             at: "center left",
//           },
//         });
//       });
    
//       node2.attr("data-hasqtip", function (d) {
//         $(this).qtip({
//           content: {
//             text:
//               '<strong>Document name:</strong><br><u class="hyperLink" onclick="showDocumentPDF($(this).text())">' +
//               d.na +
//               "</u><br><br><strong>List of clusters name:</strong><br>" +
//               createListOfDocumentClustersName(d.cl, d.na) +
//               "</u><br><strong>List of top 5 terms:</strong><br>" +
//               getListOfTermsOfDocument(d.na),
//           },
//           hide: {
//             fixed: true,
//             delay: 700,
//           },
//           show: {
//             delay: 700,
//           },
//           style: {
//             classes: "qtip-rounded qtip-shadow",
//           },
//           position: {
//             my: "center right",
//             at: "center left",
//           },
//         });
//       });
    
//       //change the node color
//       var nodes = document.getElementsByClassName("node");
    
//       for (var i = 0; i < nodes.length; i++) {
//         if ($(nodes[i]).css("fill") == oldColor) {
//           $(nodes[i]).css({ fill: color });
//         }
//       }
    
//       nodes = document.getElementsByClassName("node2");
    
//       for (var i = 0; i < nodes.length; i++) {
//         if ($(nodes[i]).css("fill") == oldColor) {
//           $(nodes[i]).css({ fill: color });
//         }
//       }
//     }
// /**
//  * Create a color palette
//  */
// function colorPalette() {
//       //create color seqs
//       var seq = new Array();
//       // seq[0] = palette('tol', 8);
//       // seq[1] = palette('tol-dv', 8);
//       // seq[2] = palette('tol-sq', 8);
//       // seq[3] = palette('tol-rainbow', 8);
//       // seq[4] = palette('cb-BrBG', 8);
//       // seq[5] = palette('cb-PRGn', 8);
//       // seq[6] = palette('cb-PiYG', 8);
//       // seq[7] = palette('cb-PuOr', 8);
//       // seq[8] = palette('cb-RdBu', 8);
//       // seq[9] = palette('cb-RdYlBu', 8);
//       // seq[10] = palette('cb-RdYlGn', 8);
//       // seq[11] = palette('cb-Spectral', 8);
//       // seq[12] = palette('cb-Paired', 8);
//       // seq[13] = palette('cb-Pastel1', 8);
//       // seq[14] = palette('cb-Pastel2', 8);
//       // seq[15] = palette('cb-Set1', 8);
//       // seq[16] = palette('cb-Set2', 8);
//       // seq[17] = palette('cb-Set3', 8);
//       // seq[18] = palette('sol-base', 8);
//       // seq[19] = palette('sol-accent', 8);
    
//       seq[3] = palette("cb-GnBu", 8);
//       seq[14] = palette("cb-YlGnBu", 8);
//       seq[16] = palette("cb-YlOrRd", 8);
//       seq[0] = palette("cb-Blues", 8);
//       seq[7] = palette("cb-PuBu", 8);
//       seq[2] = palette("cb-BuPu", 8);
//       seq[1] = palette("cb-BuGn", 8);
//       seq[4] = palette("cb-Greens", 8);
//       seq[13] = palette("cb-YlGn", 8);
//       seq[8] = palette("cb-PuBuGn", 8);
//       seq[9] = palette("cb-PuRd", 8);
//       seq[11] = palette("cb-RdPu", 8);
//       seq[10] = palette("cb-Purples", 8);
//       seq[5] = palette("cb-OrRd", 8);
//       seq[6] = palette("cb-Oranges", 8);
//       seq[12] = palette("cb-Reds", 8);
//       seq[15] = palette("cb-YlOrBr", 8);
    
//       var paletteTable = '<table style="width:100%">';
    
//       for (var j = 0; j < seq.length; j++) {
//         paletteTable += "<tr>";
//         for (var i = 1; i < seq[j].length; i++) {
//           paletteTable +=
//             "<td class='paletteCell' onclick='selectTheColor(this)' style=\"border: 1px solid white; background: #" +
//             seq[j][i] +
//             '; width: 63px; height: 20px"></td>';
//         }
//         paletteTable += "</tr>";
//       }
    
//       paletteTable += "</table>";
    
//       return paletteTable;
//     }
    






// /**
//  * Get the color code of selected cel
//  * @param element = selected cel
//  */
// function selectTheColor(element) {
//       //remove previous selected color
//       $(".paletteCell").css({ border: "1px solid white" });
    
//       //select the cell
//       $(element).css({ border: "2px solid black" });
    
//       selectedColorInPalette = rgb2hex($(element).css("background-color"));
//     }

// /**
//  * @param documentName = name of the document
//  * Show the content of the document PDF
//  */
// function showDocumentPDF(documentName) {
//       saveLog("showDocumentPDF");
    
//       if (documentName != "") {
//         documentName = documentName.replace(".txt", ".pdf");
//         window.open("./" + userID + "/" + documentName);
//       }
//     }

// /**
//  * check if the list of clusters name have the corresponding cluster name
//  * @clusterName = cluster name
//  * @list = list of clusters name
//  * @param = True: if contains
//  */
// function containsCluster(list, clusterName) {
//       var temp = list.split(",");
    
//       var result = false;
    
//       for (var i = 0; i < temp.length; i++) {
//         if (temp[i] == clusterName) {
//           return true;
//         }
//       }
    
//       return result;
//     }
//     <!-- <input
//     id="button12"
//     title="Add Cluster"
//     class="button"
//     type="button"
//     value="Add Cluster"
//     onclick="addCluster()"
//   /> -->
  
//   /**
//  * For adding new cluster context menu
//  */
// $(function () {
//       $.contextMenu({
//         selector: ".context-menu-zero",
//         callback: function (key, options) {
//           if (key == "Add") {
//             addCluster();
//           }
//         },
//         items: {
//           Add: { name: "Add Cluster", icon: "edit" },
//         },
//       });
//     });
    
//     /**
//      * Adding new empty cluster
//      */
//     function addCluster() {
//       saveLog("addCluster");
    
//       var clusterName = prompt("Please input the name of cluster:");
    
//       if (clusterName != null && clusterName != "") {
//         if (nameIsValid(clusterName)) {
//           //check if the name is valid
//           //check if the name is not already been choosen.
//           if (!nameExists(clusterName)) {
//             clusterName = clusterName.replace(" ", "_"); //for space character
    
//             createCluster(clusterName);
//             refreshTreeView();
//           } else {
//             //if name exsits
//             alert("This name has already been assigned to a cluster!");
//           }
//         } else {
//           //if name is invalid
//           alert(
//             "The name should start with [A-Za-z].\r\n" +
//               "[0-9] and '_' and '-' and [A-Za-z] are allowed for other characters."
//           );
//         }
//       }
//     }
// /**
//  * Get the number of documents of the cluster
//  * @param clusterName = cluster ID
//  * @return docNumber = number of documents of the cluster
//  */
// function numberOfDocumnets(clusterName) {
//       var docNumber = 0;
    
//       for (var i = 0; i < clusterDocuments.length; i++) {
//         if (clusterDocuments[i].cluster == clusterName) {
//           docNumber = clusterDocuments[i].docs.length;
//         }
//       }
    
//       return docNumber;
//     }
    
//     /**
//  * Add term to cluster
//  * @param clusterName = the name of clicked cluster
//  */
// function addTermToCluster(clusterName) {
//       saveLog("addTermToCluster");
    
//       var term = prompt("Add new term:");
    
//       if (term != null) {
//         $("#selectable").selectable({
//           cancel: ".ui-selected",
//         });
    
//         // check if the term exists or not
//         var terms = document
//           .getElementById(clusterName)
//           .getElementsByClassName("sortable");
    
//         if (!termExists($(terms).children(), term)) {
//           $(terms).append(
//             "<li class='ui-state-default ui-sortable-handle' onmousedown=\"wordMouseDown(event)\"><span class='terms'>" +
//               term +
//               "</span></li>"
//           );
//         } else {
//           alert('This cluster already have "' + term + '"');
//         }
//       }
//     }
/*
 * Save the current session of the user.
 */
// function saveSession() {
//       if (userID != "") {
//         if ($(".cluster").length > 0) {
//           var sessionName = prompt("Please enter name of the session:", "");
    
//           if (sessionName == null) {
//             //cancelation
//             return false;
//           }
    
//           while (!sessionNameValidity(sessionName)) {
//             alert("Invalid name! (only use alphabet characters and numbers)");
//             sessionName = prompt("Please enter name of the session:", "");
//           }
    
//           // callSaveSession(sessionName);
//         } else {
//           alert("Nothing to be saved!");
//         }
//       } else {
//         alert("Nothing to be saved!");
//       }
//     }

/*
 * Refresh list of sessions in listBox
 * @param sessionIndex = index of session that should be selected
 */
// function refreshSessionListBox(sessionIndex) {
//       $("#session_select").html("");
//       $("#session_select").append(
//         '<option value="first" disabled selected>Select Session</option>'
//       );
    
//       for (var j = 0; j < sessions.length; j++) {
//         var name = sessions[j].substring(
//           sessions[j].indexOf(" @ ") + 3,
//           sessions[j].indexOf(".session")
//         );
//         var date = sessions[j]
//           .substring(sessions[j].indexOf("#$") + 2, sessions[j].indexOf(" @ "))
//           .replace("_", ":")
//           .replace("_", ":");
    
//         var number = "";
//         if (j < 10) {
//           number = "0" + (j + 1) + ") ";
//         } else {
//           number = j + 1 + ") ";
//         }
    
//         var finalName = name + " @ " + date;
//         $("#session_select").append(
//           '<option class="d" value="' +
//             finalName +
//             '" title="' +
//             sessionsDescription[j] +
//             '">' +
//             number +
//             finalName +
//             "</option>"
//         );
//       }
    
//       $("#session_select option[value='" + sessionIndex + "']").attr(
//         "selected",
//         true
//       );
//     }


/*
 * Check if there are invalid chars in the session name or not
 * @param name = name of the session
 */
// function sessionNameValidity(name) {
//       var valid = true;
    
//       for (var i = 0; i < name.length; i++) {
//         var re = new RegExp("[A-Za-z0-9_-\\s]");
//         if (name.charAt(i).match(re) == null) {
//           valid = false;
//           break;
//         }
//       }
    
//       return valid;
//     }
    // .each(function(d) {
    //   // Calculate the total contribution for the current bar
    //   var totalContribution = d3.sum(color.domain().map(function(name) {
    //     return Math.abs(d[name]); // Use absolute value in case of negative contributions
    //   }));

    //   // Check if the current total contribution is the maximum
    //   if (totalContribution > maxContribution) {
    //     maxContribution = totalContribution;
    //     maxCluster = d.cluster; // Save the cluster name or index
    //   }
    // })
    
    
  //for cluster tooltip
  // clusterToolTip(clusterName);
  // if (currentSubset == BASELINE_LOCAL) {
  //   // panel5 cluster tree view directory
  //   let panel5 = document.getElementById("panel5");
  //   panel5.style.height = "91%";
  //   cluster_tree_view.style.top = "5%";
  //   let panel2 = document.getElementById("panel2");
  //   panel2.style.width = "66%";
  //   panel2.style.top = "7.5%";
  //   panel2.style.height = "20%";
  //   panel2.style.left = "24.25%";
  //   let button15 = document.getElementById("button15");
  //   button15.style.height = "10%";
  //   button15.style.top = "10%";
  //   let button16 = document.getElementById("button16");
  //   button16.style.height = "10%";
  //   button16.style.top = "10%";
  //   let panel2title = document.getElementById("panel2title");
  //   panel2title.style.height = "10%";
  //   let doc_select = document.getElementById("doc_select");
  //   doc_select.style.height = "10%";
  //   doc_select.style.top = "10%";
  //   let doc_content = document.getElementById("doc_content");
  //   doc_content.style.top = "20%";
  //   let panel9 = document.getElementById("panel9");
  //   panel9.style.height = "68.5%";
  //   panel9.style.top = "29%";
  //   panel9.style.width = "66%";
  // }
  // if (currentSubset == BASELINE_GLOBAL) {
  //   let panle4 = document.getElementById("panel4");
  //   panle4.style.left = "24.25%";
  //   panle4.style.width = "66%";
  //   panle4.style.height = "30%";
  //   // $("#panel4").hide();
  //   let panel3 = document.getElementById("panel3");
  //   panel3.style.left = "24.25%";
  //   panel3.style.top = "40%";
  //   panel3.style.width = "18%";
  //   let panel7 = document.getElementById("panel7");
  //   panel7.style.left = "43%";
  //   panel7.style.top = "40%";
  //   panel7.style.width = "18%";
  //   let panel8 = document.getElementById("panel8");
  //   panel8.style.left = "61.75%";
  //   panel8.style.top = "40%";
  //   panel8.style.width = "28.5%";
  //   panel8.style.height = "30%";
  //   let panel2 = document.getElementById("panel2");
  //   panel2.style.height = "41.5%";
  // }

/**
 * for auto complete of search bar
 */
// $(function () {
//     saveLog("search");
  
//     $("#textbox1").autocomplete({
//       source: function (request, response) {
//         response(
//           $.map(getWord(request.term), function (item) {
//             return { label: item, value: item };
//           })
//         );
//       },
//       select: function (event, ui) {
//         //check if the term exists or not
  
//         if (getSelectedClusterID() != "") {
//           //check if the cluster is checked
//           var term = ui.item.value;
  
//           var terms = document
//             .getElementById(getSelectedClusterID())
//             .getElementsByClassName("sortable");
  
//           var ok = confirm(
//             "Do you want to add '" +
//               term +
//               "' to cluster '" +
//               getSelectedClusterID() +
//               "'?"
//           );
  
//           // if (ok) {
//           //   if (!termExists($(terms).children(), term)) {
//           //     appendTerm(term);
//           //   } else {
//           //     alert('This cluster already have "' + term + '"');
//           //   }
//           // }
//         }
//       },
//     });
//   });

/**
 * Search the term in all words of document collocation
 * @param term = the term
 * @return the found words
 */
// function getWord(term) {
//     var foundWords = new Array();
//     var index = 0;
  
//     for (var i = 0; i < allWords.length; i++) {
//       if (allWords[i].indexOf(term) > -1) {
//         foundWords[index] = allWords[i];
//         index++;
//       }
//     }
  
//     return foundWords;
//   }


/*
 * Create list of top terms of document
 * @parm documentName = the name of the document
 * @return list of top terms of document.
 */
// function getListOfTermsOfDocument(documentName) {
//     var terms = new Array();
//     terms = getDocumentTermsSorted(documentName);
  
//     var list = "";
  
//     //show top 5 terms
//     for (var i = 0; i < terms.length; i++) {
//       if (i == 5)
//         //show top 5 terms
//         break;
  
//       list += "<span>" + terms[i][0] + "</span><br>";
//     }
  
//     return list;
//   }

/*
 * get sorted list of document terms
 * @parm documentName = the name of the document
 * @return sorted list of document terms
 */
// function getDocumentTermsSorted(documentName) {
//     var temp = termDocumentSimilarity[documentsName.indexOf(documentName)];
//     var terms = new Array();
//     var termsScore = new Array();
  
//     var index = 0;
//     for (var i = 0; i < temp.length; i++) {
//       if (temp[i] > 0.0) {
//         terms[index] = allWords[i];
//         termsScore[index] = temp[i];
//         index++;
//       }
//     }
  
//     //sort the terms by score
//     for (var i = 0; i < termsScore.length; i++) {
//       for (var j = i; j < termsScore.length; j++) {
//         if (termsScore[j] > termsScore[i]) {
//           var temp = termsScore[i];
//           termsScore[i] = termsScore[j];
//           termsScore[j] = temp;
  
//           temp = terms[i];
//           terms[i] = terms[j];
//           terms[j] = temp;
//         }
//       }
//     }
  
//     var finalTerms = new Array(terms.length);
//     for (var i = 0; i < terms.length; i++) {
//       finalTerms[i] = new Array(2);
//       finalTerms[i][0] = terms[i];
//       finalTerms[i][1] = termsScore[i];
//     }
  
//     return finalTerms;
//   }

/**
 * For right click in general view graph
 */
// $(function () {
//     $.contextMenu({
//       selector: ".context-menu-four",
//       callback: function (key, options) {
//         if (key == "ShowCloud") {
//           showSelectedDocumentsCloud();
//         }
//       },
//       items: {
//         ShowCloud: { name: "ShowCloud", icon: "edit" },
//       },
//     });
//   });
  /**
   * Show the terms cloud of selected documents in general view graph
   */
//   function showSelectedDocumentsCloud() {
//     //no user no job!
//     if (userID == "") {
//       return null;
//     }
  
//     //get the names of the selected documents
//     var selectedDocuments = new Array();
  
//     var index = 0;
//     node.filter(function (o, i) {
//       if ($($(".node")[i]).css("opacity") == 1) {
//         selectedDocuments[index] = o.na;
//         index++;
//       }
//     });
  
//     //get terms of each document and aggregate the terms
//     var aggregatedTerms = new Array(allWords.length); //allWords.length + 1);//hashmap of terms
//     // aggregatedTerms["allWords[i]"] = 0.003;
  
//     for (var i = 0; i < allWords.length; i++) {
//       //initialize the aggregatedTerms
//       aggregatedTerms[allWords[i]] = parseFloat(0.0);
//     }
  
//     for (var i = 0; i < selectedDocuments.length; i++) {
//       var temp =
//         termDocumentSimilarity[documentsName.indexOf(selectedDocuments[i])];
  
//       //add the value of each term to the aggregatedTerms
//       for (var j = 0; j < temp.length; j++) {
//         try {
//           aggregatedTerms[allWords[j]] =
//             aggregatedTerms[allWords[j]] + parseFloat(temp[j]);
//         } catch (err) {
//           console.log(err.message);
//         }
//       }
//     }
  
//     //divide the terms value by total number of selected documents (normalization of values)
//     for (var term in aggregatedTerms)
//       aggregatedTerms[term] = aggregatedTerms[term] / selectedDocuments.length;
  
//     //sort the aggregated terms
//     var aggregatedTermsSorted = [];
//     for (var term in aggregatedTerms)
//       aggregatedTermsSorted.push([term, aggregatedTerms[term]]);
  
//     aggregatedTermsSorted.sort(function (a, b) {
//       return b[1] - a[1];
//     });
  
//     //get top 30 terms
//     var wordsTemp = "";
//     for (var i = 0; i < aggregatedTermsSorted.length; i++) {
//       if (i == 0) {
//         wordsTemp +=
//           aggregatedTermsSorted[i][0] +
//           "|" +
//           Math.floor(aggregatedTermsSorted[i][1] * 30);
//       } else {
//         wordsTemp +=
//           "|" +
//           aggregatedTermsSorted[i][0] +
//           "|" +
//           Math.floor(aggregatedTermsSorted[i][1] * 30);
//       }
  
//       if (i >= 29) {
//         break;
//       }
//     }
  
//     //clear the cloud
//     $("#panel8_2").html("");
  
//     //show the terms in Term Cloud view
//     if (wordsTemp != "") {
//       var words = wordsTemp.split("|");
//       var x = document.getElementById("cloudColor");
//       var title = "Term Cloud (Selected Nodes)";
//       wordCloud(
//         wordText(words),
//         sizeOfText(words),
//         "panel8_2",
//         "panel8",
//         title
//       );
//     }
//   }




// function json2arrayRemovedDocuments(data) {
//     data = data.replace("[", "").replace("]", "");
//     data = data.split(",");
  
//     for (var i = 0; i < data.length; i++) {
//       if (data[i] == "true") {
//         removedDocuments[i] = true;
//       } else if (data[i] == "false") {
//         removedDocuments[i] = false;
//       }
//     }
//   }

        //get document-document similarity matrix
        // var temp = documentDocumentSimilarityString.split("\n"); // .split("\r\n")

        // asyncRequest.open("POST", "./cgi-bin/fetchDocumentDistance.py", false);
        // asyncRequest.setRequestHeader(
        //   "Content-Type",
        //   "application/x-www-form-urlencoded"
        // );
        // asyncRequest.send("userID=" + encodeURIComponent(userID));

        // documentDocumentSimilarityString = asyncRequest.responseText;
        // var temp = documentDocumentSimilarityString.split("\n"); // .split("\r\n")

        // for (var i = 0; i < temp.length; i++) {
        //   if (temp[i].length > 0) {
        //     documentDocumentSimilarity[i] = temp[i].split(",");
        //   }
        // }

        //get term-document matrix
        // var temp = termDocumentSimilarityString.split("\n"); // .split("\r\n")

        // asyncRequest.open("POST", "./cgi-bin/fetchMatrix.py", false);
        // asyncRequest.setRequestHeader(
        //   "Content-Type",
        //   "application/x-www-form-urlencoded"
        // );
        // asyncRequest.send("userID=" + encodeURIComponent(userID));

        // termDocumentSimilarityString = asyncRequest.responseText;
        // var temp = termDocumentSimilarityString.split("\n"); // .split("\r\n")

        // for (var i = 0; i < temp.length; i++) {
        //   if (temp[i].length > 0) {
        //     termDocumentSimilarity[i] = temp[i].split(",");
        //   }
        // }

        // //set the remove status of documents
        // for (var i = 0; i < documentDocumentSimilarity.length; i++) {
        //   removedDocuments[i] = false;
        // }

                    //check if the cluster is empty or not

            // var doc = new Array(1);
            // var color = {};
            // doc[0] = document.getElementById("doc_select").value;
            // color[doc[0]] = $("#" + clusterName + " p").css("background-color"); //"Blue";

            // paralelCordinator(
            //   documentClusterData,
            //   "#panel6",
            //   doc,
            //   "#DocumentClusterView",
            //   color
            // );

            /**
 * rename the name of cluster in tooltip of nodes in general view
 * @param clusterListNames = the old list of cluster names
 * @param oldName = old name of cluster
 * @param newName = new name of cluster
 * @return newClusters = new list of document cluster names
 */
// function renameCLusterNameInToolTip(clusterListNames, oldName, newName) {
//   var clusters = clusterListNames.split(",");

//   var newClusters = "";

//   for (var i = 0; i < clusters.length; i++) {
//     var temp = "";
//     if (clusters[i] == oldName) {
//       temp = newName;
//     } else {
//       temp = clusters[i];
//     }

//     if (newClusters == "") {
//       newClusters = temp;
//     } else {
//       newClusters += "," + temp;
//     }
//   }

//   return newClusters;
// }
  
// #!/home/ubuntu/IDC/bin/python

// #!/home/ubuntu/IDC/bin/python